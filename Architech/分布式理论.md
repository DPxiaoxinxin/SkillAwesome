# 分布式理论及实践

## 分布式一致性

### 强一致性

这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大

### 弱一致性

这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态

### 最终一致性

最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型

## CAP

* **一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance****）这三个基本需求，最多只能同时满足其中两项**。
* 对于一个分布式系统而言，分区容错性是一个最基本的要求。因为 既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网 络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构师往往需要把精力花在如何根据业务 特点在C（一致性）和A（可用性）之间寻求平衡。

| **选    择** | **说    明**                                                 |
| ------------ | ------------------------------------------------------------ |
| CA           | 放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择 |
| AP           | 放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此 |
| CP           | 放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用 |

### 一致性

在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。

* 对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进 行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是老数据（或称为脏数 据），这就是典型的分布式数据不一致的情况。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么 这样的系统就被认为具有强一致性

### 可用性

可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是"有限时间内"和"返回结果"。

* "有限时间内"是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对 应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。另外，"有限的时间内"是指系统设计之初就设计好的运行指标，通常不同系统之间有很 大的不同，无论如何，对于用户请求，系统必须存在一个合理的响应时间，否则用户便会对系统感到失望。
* "返回结果"是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出队请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。

### 分区容错性

分区容错性约束了一个分布式系统具有如下特性：**分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障**。

* 网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络） 中，由于一些特殊的原因导致这些子网络出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。 需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。

## BASE

* **即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性**。
* BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，**它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态**。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。

### 基本可用(Basically Available)

* 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性----注意，这绝不等价于系统不可用。
* 比如：
  * 响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒
  * 系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面

### 软状态(Soft State)

软状态指**允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性**，**即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时**

### 最终一致性(Eventually Consistent)

最终一致性强调的是**所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态**。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。



## 分布式锁的实现

参考：[《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)

### 分布式锁特性

- 可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。
- 这把锁要是一把可重入锁（避免死锁）
- 这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）
- 有高可用的获取锁和释放锁功能
- 获取锁和释放锁的性能要好

### 实现方案

#### 基于数据库实现分布式锁

* 优点：直接借助数据库，容易理解。
* 缺点：
  * 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。
  * 操作数据库需要一定的开销，性能问题需要考虑。
  * 使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候
  * 不可重入

##### 基于数据库表

* 最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现

  ``` sql
  CREATE TABLE `methodLock` (
    `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
    `method_name` varchar(64) NOT NULL DEFAULT '' COMMENT '锁定的方法名',
    `desc` varchar(1024) NOT NULL DEFAULT '备注信息',
    `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '保存数据时间，自动生成',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';
  ```

* 当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录

  * 对`method_name`做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。

  ```
  insert into methodLock(method_name,desc) values (‘method_name’,‘desc’)
  delete from methodLock where method_name ='method_name'
  ```

* 问题

  * 这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。
    * 搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上
  * 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。
    * 只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍
  * 这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。
    * 搞一个while循环，直到insert成功再返回成功。
  * 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。
    * 在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。

##### 基于数据库排他锁

* 借助数据中自带的锁来实现分布式的锁。 基于MySql的InnoDB引擎，可以通过数据库的排他锁来实现分布式锁。

* 在查询语句后面增加`for update`，数据库会在查询过程中给数据库表增加排他锁。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。

  * InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。

  ``` java
  public boolean lock(){
      connection.setAutoCommit(false)
      while(true){
          try{
              result = select * from methodLock where method_name=xxx for update;
              if(result==null){
                  return true;
              }
          }catch(Exception e){
  
          }
          sleep(1000);
      }
      return false;
  }
  ```

* 获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过`connection.commit()`解锁

  ``` java
  public void unlock(){
      connection.commit();
  }
  ```

* 解决了无法释放锁和阻塞锁的问题

  * 阻塞锁？ `for update`语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。
  * 锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。

* 问题

  * 无法直接解决数据库单点和可重入问题
  * 虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁
  * 使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆



### 基于缓存中间件实现分布式锁

* 优点：
  * 非阻塞，性能好
  * 可以集群部署的，解决单点问题
* 缺点
  * 操作不好容易造成锁无法释放的情况。
* 方案：[《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)

### 基于Zookepper

* 通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁
* 优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入
* 缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。

#### 原理

* zk是树形数据结构，类似linux的文件存储方式

* 加锁请求直接在"my_lock"这个锁节点下，创建一个**“临时顺序节点”**，这个顺序节点有zk内部自行维护的一个节点序号。

  * 多个客户端请求加锁，会在"my_lock"这个锁节点产生一个树形结构，又因为每层只有一个节点，类似链表

    ![](https://user-gold-cdn.xitu.io/2018/11/30/1676531b1a2a4a8a?imageView2/0/w/1280/h/960/ignore-error/1)

* 客户端创建完一个顺序节点，会查一下"**my_lock**"这个锁节点下的所有子节点，并且这些子节点是按照序号排序的

  * 如果判断自己是第一个，则进行加锁操作
  * 如果不是第一个，给上一个节点加一个监听器，等待上一个节点释放锁