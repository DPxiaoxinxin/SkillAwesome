# 扩展性设计

[TOC]

## 概念

### 扩展性

* 表现为：基础设施不需要经常变更，应用之间较少依赖或耦合，可以对需求变更快速响应
* 对扩展开放，对修改关闭
* 架构设计会考虑到未来功能的可扩展性，所以当**系统增加新功能时，不需要对现有系统的结构和代码进行修改。**

### 伸缩性

* 系统通过增加（或减少）自身资源规模的方式增强（或减少）处理业务的能力。如果这种增减是成比例的，就可以称之为线性伸缩性。
* 通常是利用集群的方式增加服务器的数量，以提高系统整体业务吞吐能力。

## 构建可扩展的网站架构

### 概述

* 度量一个开发框架、设计模式或编程语言优劣的一个重要尺度就是它是否能够让软件开发过程和软件产品更加低耦合。
  * 因为低耦合的系统更容易扩展，也更容易被复用，而且也会让开发过程和维护变得更加容易
  * 但如何分解系统的各个模块、如何定义各个模块的接口、如何复用、组合不同模块构造一个完整的系统，这是[软件设计](https://www.baidu.com/s?wd=%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)中最具挑战性的部分。
  * 软件架构师的最大价值，就在于把一个大系统分解为 N 个低耦合的子模块的能力，这些子模块包含横向的业务模块与纵向的基础技术模块。这种能力来源于专业技术能力与经验、业务场景的理解、对人性的把握以及对世界的认知
* 核心思想是模块化，并在此基础上，降低模块之间的耦合性，提高模块的复用性。
* 可以利用分层与分割的方式，把软件分割为若干个低耦合、独立的组件模块，然后在这些组件模块之间以消息传递或依赖调用的方式聚合成一个完整的系统。
  * 这些模块可以通过分布式部署的方式，部署在独立的服务器上。这种从物理上分离模块之间的耦合关系，可以进一步降低耦合性。

### 模块分布式部署后的聚合方式

#### 使用分布式消息队列降低耦合性

* 如果模块之间不存在直接调用关系，那么新增或修改模块对其他部分的影响最小，这样的扩展性自然更好。
* **事件驱动架构**：在低耦合的模块之间传输事件消息，保持模块之间的松散耦合，通过事件消息来完成模块之间的通信。 事件驱动架构最常见的实现方式就是使用分布式消息队列。

* 消息队列基于发布——订阅模式工作，消息发送者发布消息，一个或多个消息接收者订阅消息
  * 消息发送者把消息发送至分布式消息队列后就处理完毕，然后由消息订阅者从消息队列中获取消息进行处理。
  * 对于新增的业务，只要对某个消息感兴趣，就可以订阅该消息，而这对原有的系统和业务没有任何影响，从而实现系统的可扩展性设计
  * 消息接收者还可以对收到的消息再构造，定义出一个新的消息类型，然后再把消息发送给订阅了这一新消息类型的接收者。所以基于消息对象的事件驱动架构可以是一系列的流程。
  * 因为消息发送者无须等待就可以返回，所以系统具有更好的响应时间；而且在访问高峰，消息可以暂存于消息队列中，从而减轻了数据库的存储负载压力。
* 消息队列服务器上的数据可以看做是即时处理的，所以在**伸缩性**上，我们把新服务器加入分布式消息队列集群后，只需要通知生产者服务器更改消息队列的服务器列表
* 在**可用性**上，如果内存队列满了，要将消息写入磁盘，这样当消息推送模块把内存队列中的消息处理完毕后，就会把磁盘中的消息加载到队列中继续处理。
* 为了避免消息队列服务器宕机造成消息丢失，会把消息存储在消息的生产者服务器上，这样等消息确实被消息消费者服务器处理后才会删除。如果消息队列服务器宕机，生产者服务器会选择分布式消息队列服务器集群内的其他服务器发布消息。
* ![](http://upload-images.jianshu.io/upload_images/3386108-4a03ff655d6a8829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 使用分布式服务构建可复用的业务平台

##### 概念

* 分布式服务可以通过接口降低系统的耦合性，不同的子系统之间通过相同的接口描述调用服务。
* 拆分大型单体应用，把模块独立部署，降低系统耦合性
  * 纵向拆分：
    * 把一个大应用拆分为多个小应用。如果新增的业务较为独立，就直接将其设计并部署为一个独立的 Web 应用。
    * 较简单，通过梳理业务，把关联较少的业务剥离，使其成为独立的 Web 应用 
  * 横向拆分：
    * 把复用的业务拆分出来，独立部署为分布式服务，新增的业务只需要调用这些分布式的服务，就可以快速搭建出一个应用系统。即使模块内的业务逻辑发生变化，只要保持接口一致，就不会影响其他模块
    * 不仅需要识别出可复用的业务、设计服务接口以及规范服务之间的依赖关系，而且还需要一个完善的分布式服务管理框架。

* ![](http://upload-images.jianshu.io/upload_images/3386108-9cb3159fe5e473fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 大型网站分布式服务的要求

###### 负载均衡

 对于服务请求者能够使用可配置的负载均衡算法来访问热门服务（比如登录或商品服务，这些服务被部署在一个集群上）。 

###### 失效转移

可复用的服务被多个应用调用，一旦服务不可用，就会影响到很多应用的可用性。所以即使是很少访问的服务，也需要集群部署。分布式服务框架检测到某个服务不可用时，就会切换到其他服务实例上，保证整体高可用。 

###### 高效的远程通信

###### 整合异构系统

###### 对应用最小侵入

分布式服务框架支持服务（服务模块需要即支持集中式部署，也支持分布式部署）的渐进式演化和反复。 

###### 版本管理

 网站服务不可中断，所以分布式服务框架需要支持服务的多版本发布，服务提供者升级发布接口新版本的同时，还会继续支持旧版本的服务，直到请求者调用的接口升级后，才会关闭旧版本的服务。 

###### 实时监控

监控服务提供者和调用者的各项指标，提供运维与运营的支持。

##### Dubbo分布式服务框架设计

![](http://upload-images.jianshu.io/upload_images/3386108-b41feabe66a5f5a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 服务消费者通过接口使用服务，接口通过代理加载具体服务，可以是本地的代码，也可以是远程的服务，因此对应用侵入较小。
* 客户端模块通过服务注册中心加载服务提供者列表（服务提供者启动后自动向服务注册中心注册自己可以提供的服务接口列表），然后根据配置的负载均衡策略把服务调用请求发送到某台服务提供者的服务器。
  * 如果服务调用失败，客户端模块会自动从服务提供者列表中选择一个可以提供同样服务的服务器重新请求，即自动失效转移，保证服务的高可用。
* 使用 NIO 通信框架，因此具有较高的网络通信性能。

## 数据切分

### 概述

* 通过MySQLReplication功能所实现的扩展总是会受到数据库大小的限制，一旦数据库过于庞大，尤其是当写入过于频繁，很难由一台主机支撑的时候，我们还是会面临到扩展瓶颈
* 简单来说，就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果
* 数据的切分同时还可以提高系统的总体可用性，因为单台设备Crash之后，只有总体数据的某部分不可用，而不是所有的数据。
* 切分模式
  * **数据的垂直（纵向）切分：按照不同的表（或者Schema）来切分到不同的数据库（主机）之上**
    * 规则简单，实施也更为方便，尤其适合各业务之间的耦合度非常低，相互影响很小，业务逻辑非常清晰的系统
    * 在这种系统中，可以很容易做到将不同业务模块所使用的表分拆到不同的数据库中。
    * 根据不同的表来进行拆分，对应用程序的影响也更小，拆分规则也会比较简单清晰。
  * **数据的水平（横向）切分**：**根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面**
    * 于垂直切分相比，相对来说稍微复杂一些。因为要将同一个表中的不同数据拆分到不同的数据库中。
    * 对于应用程序来说，拆分规则本身就较根据表名来拆分更为复杂，后期的数据维护也会更为复杂一些。
  * **垂直切分和水平切分相结合 **
    * 当我们某个（或者某些）表的数据量和访问量特别的大，需先垂直切分，然后再水平切分，才能解决这种超大型表的性能问题。

### 垂直切分

#### 概述

* **当系统的功能模块越清晰，耦合度越低，各个模块的维护性以及扩展性也就越好**，**完全可以根据功能模块来进行数据的切分，不同功能模块的数据存放于不同的数据库主机中**
  * 可以很容易就避免掉跨数据库的Join存在，同时系统架构也非常的清晰。
* **很难有系统能够做到所有功能模块所使用的表完全独立**，完全不需要访问对方的表或者需要两个模块的表进行Join操作。**这种情况下，我们就必须根据实际的应用场景进行评估权衡。**只能在实际的应用场景中通过平衡各方面的成本和收益，才能分析出一个真正适合自己的拆分方案。
  * 迁就应用程序将需要Join的表的相关某快都存放在同一个数据库中
    * 如果是一个负载相对不是很大的系统，而且表关联又非常的频繁，那可能数据库让步，将几个相关模块合并在一起减少应用程序的工作的方案可以减少较多的工作量，是一个可行的方案。
    * 通过数据库的让步，让多个模块集中共用数据源，实际上也是简介的默许了各模块架构耦合度增大的发展，可能会让以后的架构越来越恶化。
    * 尤其是当发展到一定阶段之后，发现数据库实在无法承担这些表所带来的压力，不得不面临再次切分的时候，所带来的架构改造成本可能会远远大于最初的时候。
  * 让应用程序做更多的事情，也就是程序完全通过模块接口取得不同数据库中的数据，然后在程序中完成Join操作。

#### 优点

* 数据库的拆分简单明了，拆分规则明确
* 应用程序模块清晰明确，整合容易；
* 数据维护方便易行，容易定位；

#### 缺点

* 部分表关联无法在数据库级别完成，需要在程序中完成；
* 对于访问极其频繁且数据量超大的表仍然存在性能平静，不一定能满足要求；
* 事务处理相对更为复杂；
* 切分达到一定程度之后，扩展性会遇到限制；
* 过度切分可能会带来系统过渡复杂而难以维护。

#### 现实场景

针对于垂直切分可能遇到数据切分及事务问题，在数据库层面实在是很难找到一个较好的处理方案。实际应用案例中，数据库的垂直切分大多是与应用系统的模块相对应，同一个模块的数据源存放于同一个数据库中，可以解决模块内部的数据关联问题。而模块与模块之间，则通过应用程序以服务接口方式来相互提供所需要的数据。

* 虽然这样做在数据库的总体操作次数方面确实会有所增加，但是在系统整体扩展性以及架构模块化方面，都是有益的
* 可能在某些操作的单次响应时间会稍有增加，但是系统的整体性能很可能反而会有一定的提升



### 水平切分

#### 概述

* 主要是将某个访问极其平凡的表再按照某个字段的某种规则来分散到多个表之中，每个表中包含一部分数据。
  * 如根据某个数字类型字段基于特定数目取模，某个时间类型字段的范围，或者是某个字符类型字段的hash值。
  * 如果整个系统中大部分核心表都可以通过某个字段来进行关联，那这个字段自然是一个进行水平分区的上上之选了

#### 优点

- 表关联基本能够在数据库端全部完成；
- 不会存在某些超大型数据量和高负载的表遇到瓶颈的问题；
- 应用程序端整体架构改动相对较少；
- 事务处理相对简单；
- 只要切分规则能够定义好，基本上较难遇到扩展性限制；

#### 缺点

- 切分规则相对更为复杂，很难抽象出一个能够满足整个数据库的切分规则；
- 后期数据的维护难度有所增加，人为手工定位数据更困难；
- 应用系统各模块耦合度较高，可能会对后面数据的迁移拆分造成一定的困难。

### 组合切分

#### 概述

* 一般来说，我们数据库中的所有表很难通过某一个（或少数几个）字段全部关联起来，所以很难简单的仅仅通过数据的水平切分来解决所有问题。而垂直切分也只能解决部分问题，对于那些负载非常高的系统，即使仅仅只是单个表都无法通过单台数据库主机来承担其负载。
* 每一个应用系统的负载都是一步一步增长上来的，在开始遇到性能瓶颈的时候，大多数架构师和DBA都会选择先进行数据的垂直拆分，因为这样的成本最先，最符合这个时期所追求的最大投入产出比。然而，随着业务的不断扩张，系统负载的持续增长，在系统稳定一段时期之后，经过了垂直拆分之后的数据库集群可能又再一次不堪重负，遇到了性能瓶颈。
* 这时候我们就必须要通过数据的水平切分的优势，来解决这里所遇到的问题。**在垂直拆分基础上利用水平切分的优势**来避开垂直切分的弊端，解决系统复杂性不断扩大的问题。而水平拆分的弊端（规则难以统一）也已经被之前的垂直切分解决掉了
* ![](http://images.cnblogs.com/cnblogs_com/ggjucheng/201211/201211132252141828.jpg)

#### 优点

- 可以充分利用垂直切分和水平切分各自的优势而避免各自的缺陷；
- 让系统扩展性得到最大化提升；

#### 缺点

- 数据库系统架构比较复杂，维护难度更大；
- 应用程序架构也相对更复杂；

### 数据切分及整合方案

应用系统面临的最大问题就是如何来让这些数据源得到较好的整合

#### 解决思路

* 在每个应用程序模块中配置管理自己需要的一个（或者多个）数据源，直接访问各个数据库，在模块内完成数据的整合；	
* **通过中间代理层来统一管理所有的数据源，后端数据库集群对前端应用程序透明；(推荐)**

#### 方案

##### 自行开发中间代理层

* 可以最大程度的应对自身应用的特定，最大化的定制很多个性化需求，在面对变化的时候也可以灵活的应对
* 自然也需要投入更多的成本来进行前期研发以及后期的持续升级改进工作，而且本身的技术门槛可能也比简单的Web应用要更高一些

##### 利用MySQLProxy

##### 利用Amoeba

##### 利用HiveDB

##### 利用Mycat

### 数据切分与整合可能存在的问题

应用程序由于其特殊性，可以非常容易做到很好的扩展性，但是数据库就不一样，必须借助很多其他的方式才能做到扩展，而且在这个扩展过程中，很难避免带来有些原来在集中式数据库中可以解决但被切分开成一个数据库集群之后就成为一个难题的情况。要想让系统整体得到最大限度的扩展，我们只能让应用程序做更多的事情，来解决数据库集群无法较好解决的问题。

#### 引入分布式事务的问题

* 首先需要考虑的一件事情就是：是否数据库是唯一一个能够解决事务的地方呢？其实并不是这样的，我们完全可以结合数据库以及应用程序两者来共同解决。各个数据库解决自己身上的事务，然后通过应用程序来控制多个数据库上面的事务。
* **完全可以将一个跨多个数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控各个小事务。**
  * 这样作的要求就是我们的俄应用程序必须要有足够的健壮性，当然也会给应用程序带来一些技术难度。

#### 跨节点Join的问题

* 推荐通过应用程序来进行处理，先在驱动表所在的MySQLServer中取出相应的驱动结果集，然后根据驱动结果集再到被驱动表所在的MySQLServer中取出相应的数据。
  * 会对性能有一定的负面影响，但是除了此法，基本上没有太多其他更好的解决办法了
  * 而且，由于数据库通过较好的扩展之后，每台MySQLServer的负载就可以得到较好的控制，单纯针对单条Query来说，其响应时间可能比不切分之前要提高一些，所以性能方面所带来的负面影响也并不是太大。
  * 更何况，类似于这种需要跨节点Join的需求也并不是太多，相对于总体性能而言，可能也只是很小一部分而已。所以为了整体性能的考虑，偶尔牺牲那么一点点，其实是值得的，毕竟系统优化本身就是存在很多取舍和平衡的过程。

#### 跨节点合并排序分页问题

* 建议通过应用程序来解决，思路大体上和跨节点Join的解决类似。
  * 但是有一点和跨节点Join不太一样，Join很多时候都有一个驱动与被驱动的关系，所以Join本身涉及到的多个表之间的数据读取一般都会存在一个顺序关系。排序分页就不太一样了，排序分页的数据源基本上可以说是一个表（或者一个结果集），本身并不存在一个顺序关系，所以在从多个数据源取数据的过程是完全可以并行的。
  * 排序分页数据的取数效率我们可以做的比跨库Join更高，所以带来的性能损失相对的要更小，在有些情况下可能比在原来未进行数据切分的数据库中效率更高了