# 分布式事务

## 概念

分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）

## 2PC(Two-pharse commit)二阶段提交协议

### 概括

* **二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。**
* 主要保证了分布式事务的原子性：即所有结点要么全做要么全不做

### 步骤

#### 准备阶段(投票阶段)

事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交。

* 协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应
* 参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）
* 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。

#### 提交阶段(执行阶段)

* 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；
  * 协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。
  * 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
  * 参与者节点向协调者节点发送”回滚完成”消息。
  * 协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。
* 否则，发送提交(Commit)消息；
  * 协调者节点向所有参与者节点发出”正式提交(commit)”的请求。
  * 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
  * 参与者节点向协调者节点发送”完成”消息。
  * 协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。
* 参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)

### 缺点

#### 同步阻塞问题

执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。

#### 单点故障

于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）

#### 数据不一致

在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。

#### 脑裂

二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。



## 3PC(Three-pharse commit)三阶段提交协议

### 概述

* 是二阶段提交（2PC）的改进版本
  * 引入超时机制。同时在协调者和参与者中都引入超时机制。
  * 在第一阶段和第二阶段中插入一个状态确认阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

### 步骤

#### 准备阶段

和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。

* **事务询问** 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
* **响应反馈** 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No

#### 状态确认阶段

* **假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。**
  * **发送预提交请求** 协调者向参与者发送PreCommit请求，并进入Prepared阶段。
  * **事务预提交** 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
  * **响应反馈** 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。
* **假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。**
  * **发送中断请求** 协调者向所有参与者发送abort请求。
  * **中断事务** 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。

#### 提交阶段

* 执行提交
  * **发送提交请求** 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
  * **事务提交** 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
  * **响应反馈** 事务提交完之后，向协调者发送Ack响应。
  * **完成事务** 协调者接收到所有参与者的ack响应之后，完成事务。
* 中断事务：协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。
  * **发送中断请求** 协调者向所有参与者发送abort请求
  * **事务回滚** 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
  * **反馈结果** 参与者完成事务回滚之后，向协调者发送ACK消息
  * **中断事务** 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。

> 在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）

## TCC(Try-Confirm-Cancle)

### 概述

* 基于BASE理论：基本可用、柔性状态(中间状态)、最终一致。
* 解决方案：
  * 记录日志+补偿（正向补充或者回滚）
    * 记录事务的开始和结束状态。事务根据日志记录找回事务的当前执行状态，并根据状态决定重试异常步骤，也就是正向补偿，或者回滚上一次执行步骤，也就是反向补偿。
  * 消息重试(要求程序要幂等)
    * 多次重试，也就是发送多次消息，由于要多次重发，所以程序必须是幂等（同一操作反复执行多次结果不变），这是非常具有互联网特征的一种模式。
  * “无锁设计”、采用乐观锁机制。
    * 放弃锁是一个解决问题的思路。比如通过乐观锁，大多数是基于版本号来实现。

### 步骤

* 需引入相关的TCC框架充当协调者，感知各个阶段的执行情况以及推进执行下一个阶段。TCC事务框架会通过活动日志记录各个服务的状态。
* 加入中间状态，各服务需自行实现confirm逻辑和cancel逻辑
* **原本的一个接口，要改造为3个逻辑，Try-Confirm-Cancel**。
  - 先是服务调用链路依次执行Try逻辑
  - 如果都正常的话，TCC分布式事务框架推进执行Confirm逻辑，完成整个事务
  - 如果某个服务的Try逻辑有问题，TCC分布式事务框架感知到之后就会推进执行各个服务的Cancel逻辑，撤销之前执行的各种操作

#### Try准备阶段

* 完成所有业务检查(一致性)
* 预留必备的业务资源(准隔离性)：一般都是锁定某个资源，设置一个预备类的状态(中间状态)，冻结部分数据
  * 比如`UNPAYED->PAYED`变成`UNPAYED->UPDATING`

#### Confirm确认阶段

* 真正执行任务，不作任何业务检查
* 只使用Try阶段预备的业务资源
* Confirm操作要满足幂等性

#### Cancel取消阶段

* 释放Try阶段预备的业务资源
* Cancel操作要满足幂等性



## 2PC和3PC的区别

> 相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。

## 2PC和TCC的区别

* 2PC是从XA规范衍生出来的，更接近于底层。比如说业务要操作多个数据库完成事务，相当于业务已经执行完了，等待事务的返回结果。业务不和2pc各阶段结合，只关心2pc执行后最终的结果
  * begin -> 业务逻辑 -> prepare -> commit
* TCC是应用层的2PC，更偏向于业务上层的处理。比如说业务要根据调用链调用多个服务，每个服务去操作数据库。业务是和tcc各阶段结合起来的。
  * begin -> 业务逻辑(try业务) -> commit(comfirm业务)。
    * 2PC机制的业务阶段 等价于 TCC机制的try业务阶段；
    * 2PC机制的提交阶段（prepare & commit） 等价于 TCC机制的提交阶段（confirm）；
    * 2PC机制的回滚阶段（rollback） 等价于 TCC机制的回滚阶段（cancel）。

## 可靠消息最终一致性方案

参考：[](https://juejin.im/post/5bf2c6b6e51d456693549af4)

### 概述

* 解决各服务间异步调用的场景，TCC是同步调用的

### 实现

#### 目的

完全依赖可靠消息服务的各种自检机制确保消息执行成功。通过这套机制，保证了基于MQ的异步调用/通知的服务间的分布式事务保障。核心思想和阿里开源的RocketMQ类似(实现了可靠消息服务的所有功能)

* 如果上游服务的数据库操作没成功，下游服务是不会收到任何通知
* 如果上游服务的数据库操作成功了，可靠消息服务死活都会确保将一个调用消息投递给下游服务，而且一定会确保下游服务务必成功处理这条消息。

#### 架构

##### 上游服务

##### 可靠消息服务

* 保存消息，根据消息的状态值进行响应处理

* 含有一个**后台定时运行的线程**，不停的检查各个消息的状态
  * 如果消息一直是待确认并且超时，说明上游服务操作完本地数据库后可能在通知可靠消息服务期间出现问题，需回调上游服务接口确认。
    * 如上游服务答复执行成功，将此消息改为“已发送”，同时投递MQ
    * 如上游服务答复执行失败，将此消息删除
  * 如果消息状态一直是“已发送”，始终没有变成“已完成”，那么就说明下游服务始终没有处理成功。
    * 此时可靠消息服务就可以再次尝试重新投递消息到MQ，让下游服务来再次处理(下游服务的接口逻辑**实现幂等性**，保证多次处理一个消息，不会插入重复数据)

##### MQ消息队列

* 基于KV存储的队列支持的高可用降级方案

  ![](https://user-gold-cdn.xitu.io/2018/11/19/1672c7a396a84cda?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

##### 下游服务

#### 步骤

##### 上游服务投递消息

* 上游服务发送一条消息给可靠消息服务
* 可靠消息服务就得把这条消息存储到自己的数据库里去，状态为“待确认”
* 上游服务就可以执行自己本地的数据库操作，根据自己的执行结果，再次调用可靠消息服务的接口
  * 本地数据库操作执行成功了，那么就找可靠消息服务确认那条消息，那么可靠消息服务就把数据库里的消息状态更新为“已发送”，同时将消息发送给MQ(**更新状态和投递MQ是同一个事务**)
  * 如果本地数据库操作失败了，那么就找可靠消息服务删除那条消息。

##### **下游服务接收消息**

* 下游服务就一直等着从MQ消费消息，如果消费到了消息，那么就操作自己本地数据库
* 如果操作成功，就反过来通知可靠消息服务，说自己处理成功了，然后可靠消息服务就会把消息的状态设置为“已完成”。