# Spring Cloud

## 核心组件

### Eureka注册中心

#### 角色

* **Eureka Client**： 每个服务有一个Eureka Client，负责将这个服务的信息注册到Eureka Server中
* **Eureka Server：**注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号

#### 示例

* 默认情况下，Client每隔30s从Server拉取最新的注册表，每隔30s发送一次心跳，即1min有4次请求
* 假设有100个服务，每个服务20台机器，日访问量：100 * 20 * 4 * 60 * 24 = 1152w，千万级别

#### 内部结构

* 注册表基于纯内存，使用**CocurrentHashMap**数据结构

  * 各个服务的注册、服务下线、服务故障，全部会在内存里维护和更新这个注册表
  * 各个服务每隔30秒拉取注册表的时候，Eureka Server就是直接提供内存里存储的有变化的注册表数据给他们就可以了

* 多级缓存机制
  * 在拉取注册表的时候：

    * 首先从**ReadOnlyCacheMap**里查缓存的注册表。
    * 若没有，就找**ReadWriteCacheMap**里缓存的注册表。
    * 如果还没有，就从**内存中获取实际的注册表数据。**

  * 在注册表发生变更的时候：

    - 会在内存中更新变更的注册表数据，同时**过期掉ReadWriteCacheMap**。
    - 此过程不会影响**ReadOnlyCacheMap**提供人家查询注册表。
    - 一段时间内（默认30秒），各服务拉取注册表会直接读**ReadOnlyCacheMap**
    - 30秒过后，Eureka Server的后台线程发现**ReadWriteCacheMap**已经清空了，也会清空**ReadOnlyCacheMap**中的缓存
    - 下次有服务拉取注册表，又会从内存中获取最新的数据了，同时填充各个缓存。

  * 优点

    * 尽可能保证了内存注册表数据不会出现频繁的读写冲突问题。

    - 并且进一步保证对Eureka Server的大量请求，都是快速从纯内存走，性能极高。

* 

### Ribbon负载均衡客户端

#### 角色

* 服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台(默认**Round Robin轮询算法**)
* **Ribbon是和Feign以及Eureka紧密协作，完成工作**
  * Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。
  * 然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器
  * Feign就会针对这台机器，构造并发起请求。



### Feign服务消费

#### 角色

基于Feign的动态代理机制，根据注解`@FeignClient`定义的服务接口和Ribbon选择的机器，拼接请求URL地址，发起请求

#### 原理

* 某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理

* 调用这个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心

* Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址

* 最后针对这个地址，发起请求、解析响应

### Hystrix熔断器

#### 角色

* Hystrix是隔离、熔断以及降级的一个框架。
  * 通过线程池隔离不同服务，避免服务雪崩
  * 如某服务不可用，在指定时间内熔断，不再发起请求。超过一定时间后会尝试发起请求，如服务恢复正常则不再熔断。
  * 熔断的请求可配置降级处理

* 发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题

### Zuul网关

#### 角色

* 前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务
* 可以做**统一的降级、限流、认证授权、安全**