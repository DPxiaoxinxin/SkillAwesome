## AOP

### 定义

AOP（Aspect Oriented Programming），即面向切面编程，它利用一种称为"横切"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为"Aspect"，即切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。

AOP把软件系统分为两个部分：**核心关注点**和**横切关注点**。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。

### 使用的设计模式：代理模式

### Spring对AOP的支持

**Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理**。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：

* **默认使用Java动态代理来创建AOP代理**，这样就可以为任何接口实例创建代理了
* **当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理**，也可强制使用CGLIB

## IOC

### 依赖倒置原则

* 假设我们设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。
* 这样的设计看起来没问题，但是可维护性却很低。如果轮胎改动，整个设计都得改。
* 换一种思路。我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，依赖关系就倒置过来了：轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。这样改动底层的轮胎，不需要改动其他部分。
* 这就是依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。

### 定义

* **控制反转（Inversion of Control）** 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的**依赖注入（Dependency Injection）**。**所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制**”。

  ``` java
  # 下层控制上层示例，轮胎的大小通过各层的构造函数一层层往下传递
  int size = 40;
  Car mycar = new Car(size);
  mycar.run()
      
  # 上层控制下层。这一段就是控制反转容器（IOC container），从上往下寻找依赖，再从底层往事一步步实例化注入到所需的对象中
  int size = 40;
  Tire tire = new Tire(40);
  Bottom bottom = new Bottom(tire);
  Framework framework = new Framework(Bottom);
  Car car = new Car(framework);
  car.run();
  ```

* 传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。

* 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”

  * **谁依赖于谁：**当然是应用程序依赖于IoC容器；
  * **为什么需要依赖：**应用程序需要IoC容器来提供对象需要的外部资源
  * **谁注入谁：**很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；
  * **注入了什么 ** ：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。

* IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。

   



## 主要模块

