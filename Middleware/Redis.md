# Redis

[TOC]



## 数据结构

### 字符串

- 值可以是任意字符串、数字、二进制，最大值不超过512M
- 尽量使用批量操作，降低网络IO时间
- 内部编码
  - int：8个字节的长整形
  - embstr：小于等于39个字节的字符串
  - raw：大于39个字节的字符串
- 使用场景
  - 缓存功能
  - 计数
  - 共享Session
  - 限速
    - 手机验证码

### 哈希/字典

- 内部编码
  - ziplist(压缩列表)
  - hashtable(哈希表)
- 使用场景
  - 记录数据库相关表数据
    - 与数据库区别
      - 哈希类型是稀疏的，而关系型数据库是完全结构化的
      - 关系型数据库可以做复杂的关系查询

### 列表

- 使用索引下标进行排序，有序，最多存储2^32 -1 个元素，元素可重复
- 内部编码
  - ziplist(压缩列表)
  - linkedlist(链表)
- 使用场景
  - 消息队列
  - 文章列表

### 集合

- 无序，最多存储2^32 -1 个元素，元素不可重复
- 内部编码
  - intset(整数集合)
  - hastable(哈希表)
- 使用场景
  - 标签
    - 根据用户兴趣建立标签
      - 给标签添加用户
      - 给用户添加标签

### 有序集合

- 不可重复，给每个成员一个score作为排序依据
- 内部编码
  - ziplist(压缩列表)
  - skiplist(跳跃表)
- 使用场景
  - 排行榜系统
    - 时间
    - 播放量
    - 赞数

## 持久化

### RDB

#### 介绍

- 把当前进程数据生成快照保存到磁盘的过程

#### 触发机制

##### 手动触发

- save

  - 阻塞当前Redis服务器，直到RDB过程完成
  - 对内存比较大的实例会造成长时间阻塞，线上环境不建议使用
  - 废弃

- bgsave(主流方式)

  - 执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束
  - 阻塞只发生在fork阶段，一般时间很短

  - 优点
    - RDB是一个紧凑压缩的二进制文件，代表Redis某个时间点上的快照。**非常适合备份，全量复制等场景**
    - Redis加载RDB恢复数据远远快于AOF的方式
  - 缺点
    - **RDB方式数据没办法做到实时持久化/秒级持久化。因为fork属于重量级操作，频繁执行成本过高**
    - RDB文件使用特定二进制格式保存，老版本无法兼容

##### 自动触发

- 触发场景
  - 使用save相关配置，如save m n。表示m秒内数据集存在n次修改，自动触发bgsave
  - 如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从结点
  - 执行debug reload命令重新加载Redis时，也会自动触发save操作
  - 默认情况下执行shutdown命令，如果没有开启AOF持久化功能则自动执行

### AOF

#### 介绍

- 以独立日志的方式记录每次写命名，重启时再重新执行AOF文件中的命令达到恢复数据的目的
- **主要作用是解决了数据持久化的实时性，是Redis持久化的主流方式**

#### 工作流程

##### 命令写入

- 操作: 所有的写入命令会追加到aof_buf缓冲区
- 内容: 文本协议格式

##### 文件同步

- 操作：AOF缓冲区根据对应的策略向硬盘同步操作
- 同步策略
  - always
    - 命令写入aof_buf后调用系统fsync操作同步到AOF文件，fsync完成后线程返回
    - 在一般SATA硬盘上不建议配置，与Redis高性能背道而驰
  - everysec
    - 命令写入aof_buf后调用系统write操作，write完成胡线程返回。fsync同步文件操作由专门线程每秒调用一次
    - 建议和默认的配置，兼顾性能和安全性，理论上只有在系统宕机的情况下丢失1秒的数据
  - no
    - 命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒
    - 每次同步AOF周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但安全性无法保证

##### 文件重写

- 操作
  - 随着AOF文件增大，需要定期对AOF进行重写，达到压缩的目的
  - 把Redis进程内的数据转化为写命令同步到新AOF文件的过程
    - 超时数据不再写入
    - 旧AOF文件中含有无效的命令
    - 多个写命令可以合并成一个
- 过程
  - 手动触发
  - 自动触发
- 流程
  - 父进程fork完子进程后继续执行命令，后续命令继续写入AOF缓冲区保证原有AOF机制正确，同时使用AOF重写缓冲区保存这部分新数据
  - 子进程根据内存快照，写入新的AOF文件
  - 子进程写入完成后，发送信号给父进程，父进程跟新统计信息
  - 父进程把AOF重写缓冲区的数据写入新的AOF文件
  - 使用新的AOF文件替换老文件

##### 重启加载

- 操作
  - Redis重启时，可以加载AOF文件进行数据恢复
  - AOF和RDB文件都可以用于重启恢复，优先考虑AOF

### 问题优化和定位

#### 改善fork操作的耗时

- 优先使用物理机或高效支持fork操作的虚拟化技术，避免使用Xen
- 控制Redis实例最大可用内存
- 合理配置Linux内存分配策略
- 降低fork操作的频率

#### 子进程开销监控和优化

- CPU
  - 开销分析
    - 子进程负责把进程内的数据分批写入文件，CPU利用率接近90%
  - 消耗分析
    - Redis是CPU密集型服务，不要做绑定CPU操作。由于子进程非常消耗CPU，会和父进程产生单核竞争
  - 优化
    - 不要和其他CPU密集型服务部署在一起
    - 如果部署多个Redis实例，尽量保证同一时刻只有一个子进程进行重写操作
- 内存
  - 消耗分析
    - fork理论上需要两倍的内存来完成持久化，但Linux有写时复制机制。
  - 消耗监控
    - 持久化时查看日志
  - 优化
    - 多个Redis实例同CPU优化一样
    - 避免在大量写入时做子进程重写操作，这样将导致父进程维护大量页副本，造成内存消耗
      - Linux 2.6.38后需关闭THP。THP 开启时可以降低fork子进程的速度，但执行fork后，复制页单位会增大，大幅增加重写期间父进程内存消耗
- 硬盘
  - 开销分析
  - 优化
    - 不要和其他高硬盘负载的服务部署在一起
    - AOF重写时会消耗大量磁盘IO，可以开启相关配置，在AOF重写期间不做fsync操作
    - 当开启AOF并用于高流量写入场景时，如果使用的是机械硬盘，瓶颈主要在同步磁盘上
    - 对单机配置多个Redis实例上，可以配置不同实例分盘存储AOF文件

#### AOF追加阻塞

- 使用erverysec同步策略，Redis会使用另一条线程每秒执行fsync同步磁盘，当系统资源繁忙，会造成Redis主线程阻塞
- 优化系统磁盘负载

#### 多实例部署

- 外部程序定时轮询监控机器上所有Redis实例

## 复制

### 拓扑结构

#### 一主一从

- 场景：应用写命令并发量高且需要持久化时，可以只在从结点开启AOF

#### 一主多从

- 场景
  - 实现读写分离
  - 对于读占比较大的应用，可以把命令分摊到多个从节点
  - 对于写并发量较高的场景，多个从节点会导致主节点过度消耗网络带宽，也加重主节点的负载

#### 树状主从

- 引入复制中间层，有效降低主节点负载和需要传送给从结点的数据量

### 原理

#### 复制过程

- 保存主节点信息
- 主从建立socket连接
- 发送ping命令
- 权限校验
- 同步数据集
- 命令持续复制

#### 数据同步

- 全量复制
  - 一般用于初次复制场景
  - 数据量较大时会造成很大开销
- 部分复制

## Redis内存

#### 内存消耗划分

##### 自身内存

##### 对象内存

- 占用最大

##### 缓冲内存

- 客户端缓冲
  - 普通客户端
  - 从客户端
  - 订阅客户端
- 复制积压缓冲区
- AOF缓冲区

##### 内存碎片

- 解决方式
  - 数据对齐
  - 安全重启

#### 内存管理

- 设置内存上线
- 动态调整内存上限
- 内存回收策略
  - 删除达到过期时间的键
    - 惰性删除
    - 定时任务删除
  - 内存达到上限时触发内存溢出控制策略

#### 内存优化

- redisobject对象
- 缩减键值对象
- 共享对象池
- 字符串优化
- 编码优化
- 控制键的数量

## 高级特性

- 慢查询分析
- Redis shell
- Pipeline
- 事务与Lua
- Bitmaps
- HyperLogLog
- 发布订阅
  - 使用场景
    - 聊天室
    - 公告牌
- GEO(地理信息定位)

## 架构

### 单线程

#### 实现

- 所有命令都会进入一个队列，无法保证顺序，但不会并发执行

#### 为什么能达到每秒万级别的处理能力

- 纯内存访问
- 非阻塞IO，使用epoll作为IO多路复用的实现，再加上Redis自身的事件处理模型将epoll的连接、读写、关闭都转换为事件，不在网络IO上浪费时间
- 单线程避免了线程切换和竞态产生的消耗

### I/O多路复用

## 缓存设计

### 缓存的收益和成本

- 收益
  - 加速读写
  - 降低后端负载
- 成本
  - 数据不一致
    - 缓存层和存储层的数据存在一定时间窗口的不一致性，时间窗口和维护成本有关
    - 代码维护成本
    - 运维成本
- 使用场景
  - 开销大的复杂计算
  - 加速响应请求

### 缓存更新策略

#### LRU/LFU/FIFO算法删除

- 使用场景
  - 用于缓存量超过了预设的最大值的时候，如何对现有的数据进行删除
- 一致性
  - 要清理的数据由算法决定，开发人员只能决定用哪种算法，所以数据的一致性是最差的
- 维护成本
  - 算法不需要由开发人员来实现，只要选择合适的算法

#### 超时删除

- 使用场景
  - 通过给缓存数据设置过期时间，让其在过期时间后自动删除
  - 业务可忍受一段时间内，数据不一致的问题
- 一致性
  - 一段时间窗口内存在一致性问题
- 维护成本
  - 维护成本不高，只需设置过期时间

#### 主动更新

- 使用场景
  - 应用方对于数据的一致性要求高，需要在真实数据更新后，立即跟新缓存数据
  - 例如可以利用消息系统或其它方式通知缓存更新
- 一致性
  - 一致性最高，但如果主动更新发生问题，该条数据可能很长时间不更新，建议和超时删除一起使用
- 维护成本
  - 维护成本比较高，开发人员需自己来更新并保证更新操作准确性

#### 最佳实践

- **低一致性业务建议配置最大内存和淘汰策略的方式使用**
- **高一致性业务可以结合使用超时删除和主动更新**

### 缓存粒度控制

- 问题
  - 缓存数据库某个表的全部属性还是部分重要属性？
- 考虑维度
  - 通用性
    - 缓存全部数据比部分数据更加通用，但实际上，很长时间内应用只需要几个重要属性
  - 空间占用
    - 全部数据会造成内存浪费
    - 全部数据传输时占用的网络带宽大，耗时大，极端情况下阻塞网络
    - 全部数据的序列化和反序列化的CPU开销更大
  - 代码维护
    - 全部数据的优势更明显，部分数据可能需要修改业务代码，修改后还需要刷新缓存

### 穿透优化

#### 介绍

- 查询一个不存在的数据，缓存层和存储层都不会命中
- 通常出于容错考虑，查不到的数据不写入缓存层

#### 后果

- 导致不存在的数据到要到存储层查询，失去了缓存保护后端存储的意义
- 可能会使后端存储负载加大，由于很多后端存储不具备高并发，甚至会导致后端存储宕掉

#### 原因

- 自身业务代码或者数据出现问题
- 恶意攻击、爬虫

#### 解决方案

##### 缓存空对象

- 问题
  - 空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间
    - 针对这类数据设置一个较短的过期时间
  - 可能会有一段时间窗口的数据不一致，对业务有一定影响
    - 利用消息系统或其他方式删除这些空对象

##### 布隆拦截过滤器

- 介绍
  - 在访问缓存层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截
  - 不存在的key直接返回，不继续访问
- 使用场景
  - 适用于数据命中不高、数据相对固定、实时性低(通常是数据集较大)的场景，代码维护较为复杂，但是缓存空间占用少

### 无底洞优化

- 更多的节点并不代表更高的性能

### 雪崩优化

#### 避免缓存层宕掉

- 保证服务层服务高可用性
- 依赖隔离组件为后端限流并降级
- 提前演练

#### 热点key重建优化

##### 介绍

- 缓存+过期时间可以满足大部分需求
- 当前key是一个热点key，并发量非常大
- 重建缓存不能在短时间完成，可能是一个复杂计算
- 缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，深圳崩溃

##### 制定目标

- 减少重建缓存的次数
- 数据尽可能一致
- 较少的潜在危险

##### 解决方案

- 互斥锁
  - 只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可
  - 方案思路较简单，但如果构建缓存过程出现问题或时间较长，可能会存在死锁和线程池被阻塞风险，但这种方法能够较好地降低后端存储负责，并在一致性上做到最好
- 永远不过期
  - 介绍
    - 从缓存层看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题
    - 从功能层面看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间，会使用单独的线程去构建缓存
    - 唯一不足的就是重构缓存期间，会出现数据不一致的问题
  - 分析
    - 由于没有设置真正的过期时间，实际上已不存在热点key的危害，但会存在数据不一致的情况，同时代码复杂度会增大