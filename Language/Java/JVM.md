# JVM

[TOC]

## 内存区域

### 运行时数据区域

#### 程序计数器(线程私有)

- 较小的内存空间，当前线程所执行的字节码的行号指示器
- **字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**
- **唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期和线程相同**

#### Java虚拟机栈(线程私有)

- Java方法执行的内存模型，创建一个栈帧存储数据
  - 局部变量表
    - 编译期可知的各种基本数据类型，对象引用，比如：方法中的局部变量
    - returnAddress地址，指向一条字节码指令的地址
  - 操作数栈
  - 动态链接
  - 方法出口
- **Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**
  - **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
  - **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

#### 本地方法栈(线程私有)

- 与Java虚拟机栈类似，只不过是用到Native方法

#### Java堆(线程共享)

- 内存最大的一块
- 存放对象实例，几乎所有的对象实例都在这里
  - 对象实例
    - 类中的成员变量
  - 数组

#### 方法区(线程共享)

- 存储类型
  - 已被虚拟机加载的类信息
  - 常量
  - 静态变量
  - 即时编译后的代码
- HotSpot把GC分代收集方法扩展至方法区，或者说用永久代来实现方法区，但本质上两者并不等价

#### 运行时常量池(线程共享，JDK1.7之前属于方法区，之后在堆开辟一块区域)

- 编译期生成的各种字面量和符号引用
  - 字面量：
    - 文本字符串
    - 被声明为final的常量
    - 基本数据类型的值
    - 其它
  - 符号引用
    - 类和结构的完全限定名
    - 字段和描述符
    - 方法名称和描述符
- 动态性
  - 常量不一定在编译期产生，也可以在运行期生成。如String类的intern()方法

### 直接内存

- 不是虚拟机运行时数据区
- 不是Java虚拟机规范中定义的内存区域
- 如NIO使用Native函数直接分配的堆外内存

## HotSpot 虚拟机对象分配、布局和访问的全过程

### 对象的创建

#### **类加载检查**

* 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程

#### **分配内存**

* 对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。
* 分配方由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能(标记-清除or标记-整理)决定
  * 指针碰撞：
    * 堆内存规整，即没有内存碎片的情况下
    * 原理：用过的内存全部整合到一边，没有用过的内存整合到另一边，中间有一个分界值指针，只要向着没用过的内存方向将该指针移动内存大小位置即可
    * GC收集器：Serial、ParNew
  * 空闲列表：
    * 适用场合：堆内存不规整的情况下
    * 原理：虚拟机会维护一个列表，该列表中会记录哪块内存是可用的，在分配的时候，找一块足够大的内存块来分配给对象实例，然后更新列表记录
    * GC收集器：CMS
* 虚拟机采用两种方式来保证内存并发分配时的线程安全
  * **CAS+失败重试**
  * **TLAB：** 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配

#### **初始化零值**

* 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### **设置对象头**

* 初始化零值完成之后，**虚拟机要对对象进行必要的设置**。例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。**这些信息存放在对象头中。**
* 根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### **执行 init 方法**

* 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。
* 一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象的内存布局

#### **对象头**

* **存储对象自身的自身运行时数据**（哈希码、GC分代年龄、锁状态标志等等）
* **类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

**实例数据**

* **对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

#### **对齐填充**

* **不是必然存在的，也没有什么特别的含义，仅仅起占位作用**
  * 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍

### 对象的访问定位

#### **使用句柄**

* Java堆中将会划分出一块内存来作为句柄池，Java虚拟机栈的reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息； 

  ![](https://camo.githubusercontent.com/5923998f8408ea936a0416291faf1b2a1d215108/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f32372f313633303662393537333936383934363f773d37383626683d33363226663d706e6726733d313039323031)

#### 直接指针

* Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。

  ![](https://camo.githubusercontent.com/af3d3845b1d5d9c1927e77f79d2cb96ea84090fe/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f32372f313633303662613361343162366236353f773d37363626683d33353326663d706e6726733d3939313732)

## 垃圾回收

### 回收的对象

#### 对象死亡标记

##### 引用计数法

- 每有一个引用，引用计数器加1
- 无法解决对象间相互循环引用而外部无法访问的问题

##### 可达性分析(采用的)

- 通过一系列"GC Roots"向下搜索节点，走过的路径称为引用链
- GC Roots
  - 虚拟机栈中引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI(一般成为Native)引用的对象

#### 引用类型

##### 强引用(Strong)

- 程序代码中普遍存在
- 只要还存在，永远不会被GC

##### 软引用(Soft)

- 描述一些有用但非必须的对象。如果内存空间足够，垃圾回收器就不会回收它
- 系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收
- 第二次回收还没有足够的内存，才会抛出内存溢出异常

##### 弱引用(Weak)

- 描述非必需对象
- 比软引用更弱
- GC工作时无论内存是否足够一定会回收

##### 虚引用(Phantom)

- 最弱的引用关系
- 虚拟引用的存在不会对对象生存空间构成影响，也无法获得一个对象实例
- 目的是在这个对象被GC时收到一个系统通知

#### 对象死亡过程

- 第一次标记
  - 可达性分析后没有引用链，第一次标记并进行筛选是否有必要执行finalize()方法
  - 当对象的finalize()没有覆盖或已被虚拟机调用，则没有必要执行第二次标记
- 第二次标记
  - 有必要执行finalize()方法
    - finalize只会被执行一次
    - 尽量不要使用这个对象，忘掉它！不是析构函数，不要用来拯救对象
  - 对象将会被放置在一个F-Queue队列中
  - 虚拟机自动建立的、低优先级的Finalizer线程去执行该队列中对象的finalize方法
    - 不承诺等待他运行结束
    - 是对象逃脱死亡的最后一次机会
  - 稍后GC对F-Queue的对象进行第二次小规模标记
    - 标记前对象逃离死亡只需重新加入引用链

#### 回收方法区

* 废弃常量

- 无用的类

### 垃圾收集算法

#### 基础知识

##### 标记-清除法

- 不足
  - 标记和清除两个过程的效率都不高
  - 会产生大量不连续的碎片，如过多会导致新分配较大对象时而提前触发垃圾回收

##### 复制算法

- 概览：内存分为两块，清除时复制有用的
- 不足
  - 使用内存缩小为原来的一半，代价略高
- 使用场景
  - 新生代
    - 一块较大的Eden空间和两块较小的Survivor空间，HotSpot虚拟机默认比例为8：1：1
    - Survivor区不够用，需要依赖老年代进行分配担保

##### 标记-整理算法

- 使用场景
  - 老年代

##### 分代收集算法

- 划分不同区域根据特点分别使用适合的算法

#### HotSpot的垃圾回收算法实现

##### 枚举根结点

- 可达性算法不足
  - 方法区过大，逐个检查引用消耗很多时间
  - 为保证一致性，会出现GC停顿而停止所有Java线程
- HotSpot的准确式GC
  - 使用一组称为OopMap的数据结构获取那些内存区域存放着对象引用
  - 在类加载的时候，把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用

##### 安全点

- 设计原因：引用关系的变化，如果为每一条指令生成对应的OopMap，会需要大量额外的空间，GC的空间成本会非常高

- 程序执行时并非在所有地方都停顿下来开始GC，只有达到安全点才能暂停

- 安全点的选定因素

  - 是否具有让程序长时间执行的特征
    - 不能让GC等待太长
    - 不能过于频繁增加负荷
  - 如何在GC发生时让所有线程都跑到安全点才停止
    - 抢占式中断(几乎不使用): GC时让所有线程中断，未在安全点的线程会恢复继续跑直到安全点
    - 主动式中断: 设置一个标志，各线程主动去轮询

  

##### 安全区域

- 设计原因：安全点进入是在线程执行的情况下，假如线程不执行就没发跑到安全点中断
- 指一段代码片段中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的，可视为扩展的安全点
- 过程
  - 线程执行到安全区域的代码时，首先标记自己进入安全区域
  - 要发起GC时，JVM就不用管标识为安全区域状态的线程
  - 线程要离开时，要检查系统是否已经完成根结点枚举或整个GC过程
    - 如完成则继续执行
    - 如不完成就必须等待到可以离开的信号

##### 垃圾回收器

###### Serial收集器(新生代)

- 概览
  - 单线程收集器
    - 只用单CPU或单线程去完成垃圾回收
    - 必须暂停所有其他工作线程
  - 最基本、发展最悠久，JDK1.3之前的唯一选择
- 使用场景
  - 虚拟机运行在Client模式下的默认新生代收集器(简单高效)
- 分类
  - Serial收集器工作在新生代
  - Serial Old收集器工作在老年代

###### ParNew收集器(新生代)

- 概览
  - Serial的多线程版本
    - 在单CPU环境中绝不会有比Serial更好的效果，在使用超线程技术实现的两个CPU环境都不会超越
- 使用场景
  - 大多数运行在Server模式下的虚拟机首选的新生代收集器
    - 除了Serial，只有它能与CMS收集器配合工作
- 其他
  - 并行(Parallel)
    - 多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态
  - 并发(Concurrent)
    - 用户线程和垃圾回收线程同时执行(不一定是并行的可能会交替执行)，用户程序在继续运行，而垃圾回收程序运行在另一个CPU上

###### Parrel Scavenge收集器(新生代)

- 概览
  - 新生代收集器，也使用复制算法。也是并行的多线程收集器
  - 关注点
    - 其他收集器关注的是尽可能地缩短垃圾收集时用户线程停顿的时间
    - Parrel Scavenge则是达到一个可控制的吞吐量，吞吐量=运行用户代码的时间/(运行用户代码的时间+垃圾回收的时间)
- 使用场景
  - 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务
- 参数
  - 控制最大垃圾收集停顿时间
  - 吞吐量大小
  - 开关参数：-XX:+UseAdaptiveSizePolicy
    - 开启后不需要指定新生代老生代等细节参数
    - 虚拟机会采用GC自适应的调节策略，根据当前系统状态动态调节参数

###### Serial Old收集器(老年代)

- 概览
  - Serial的老年代版本
- Server模式下的两大用途
  - 在JDK1.5及之前的版本与Parrel Scavenge收集器搭配
  - 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用

###### Parrel Old收集器(老年代)

- 概览
  - Parrel Scavenge的老年代版本，在注重吞吐量和CPU资源敏感的场景，可以PS搭配使用
  - JDK1.6提供

###### CMS(Concurrent Mark Sweep)收集器(老年代，标记-清除)

- 概览
  - 以获取最短回收停顿时间为目标
  - 老年代
- 使用场景：作为Web的Java应用
- 过程
  - 初始标记
    - 需要Stop The World
    - 仅仅只是标记一下GC Roots能直接关联到的对象，速度很快
  - 并发标记
    - 进行GC Roots Tracing的过程
  - 重新标记
    - 需要Stop The World
    - 修正并发标记期间用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记长，总时间远比并发标记短
  - 并发清除
- 缺点
  - 对CPU资源非常敏感
    - 并发阶段占用CPU是用户程序变慢，总吞吐量降低
    - CPU在4个或以上时，垃圾回收线程不少于25%的CPU，并随着CPU数量增加而下降
    - CPU不足2个，对用户程序的影响非常大
  - 无法处理浮动垃圾，可能出现Concurrent Mode Failure导致另一次Full GC产生
    - CMS收集器需要预留一部分空间提供并发收集的程序运作使用，但预留的内存无法满足程序需要，就会出现
    - 后备预案，启动Serial Old收集器
  - 可能会有大量空间碎片
    - 解决方案
      - 在CMS收集器顶不住要进行FullGC是开启内存碎片合并整理过程，但停顿时间会变长

###### G1(Garbage-First)收集器(新生代&老年代)

- 使用场景：面向服务端
- 概览
  - JDK9以后的默认垃圾回收算法
- 特点
  - 并行与并发
    - 充分利用硬件优势缩短停顿时间
    - 部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发让Java程序继续执行
  - 分代收集
    - 不需要与其他收集器配合而管理整个堆
  - 空间整合
    - 整体看是基于标记-整理算法
    - 局部(两个Region)是基于复制算法
  - 可预测的停顿
    - 相对于CMS的另一大优势
    - 除了追求低停顿，还能建立可预测的停顿时间模型
      - 让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒
    - 原因
      - G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需要的经验值)
      - 在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region(Garbage-First的由来)
- 内存布局
  - 将整个Java堆划分为多个大小相等的独立区域(Region)
  - 虽然还保留新生代老年代的概览，但它们不再是物理隔离的，都是一部分Region(不需要连续)的集合
- Remembered Set操作
  - 原因
    - 一个对象可能与多个Region中的其他对象引用，如何避免全堆扫描保证准确性
  - 过程
    - 每个Region都有一个与之对应的Remembered Set
    - 虚拟机发现程序在对Reference类型的数据进行写操作，会产生一个Write Barrier暂时中断写操作，检查Region引用的对象是否存在于不同的Region
    - 如果是，通过CardTable把相关引用信息记录到Rembered Set之中
  - 进行内存回收时，在GC根结点的枚举范围中加入Rembered Set即可保证不进行全堆扫描也不会有遗漏
- 过程(不包含Rembered Set)
  - 初始标记
    - 仅仅只是标记一下GC Roots能直接关联到的对象，速度很快
    - 需要Stop The World
    - 修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region创建对象
  - 并发标记
    - 才GC Root开始对堆进行可达性分析，找出存活对象
    - 耗时较长，可并发执行
  - 最终标记
    - 修正并发标记期间用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
    - 这段时间对象变化记录在线程Remembered Set Logs里面，最终合并到Remembered Set中
    - 需停顿线程，但可并行执行
  - 筛选回收
    - 对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划
    - 需停顿用户线程
      - 可并发执行，但因为只回收一部分Region，时间可控，而且停顿用户线程可大幅提高收集效率

##### 内存分配与回收策略

###### 对象优先在Eden分配

- 没有足够空间，将发起一次Minor GC

###### 大对象直接进入老年代

- 大对象
  - 需要大量连续内存空间的Java对象
    - 很长的字符串以及数组
  - 需要避免出现

###### 长期存活的对象将进入老年代

- 每次对象进过一次Minor GC后仍存活，年龄+1，超过默认的15岁就进入老年代
- Survivor空间中相同年龄所有对象大小的综合大于该区域的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

###### 空间分配担保

- Minor GC发生前的操作
  - 虚拟机会检查老年代最大的连续空间是否大于新生代所有对象总空间
    - 成立，Minor GC是安全的
    - 不成立，查看HandlePromotionFailue是否允许担保失败
      - 允许，继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小
        - 大于，尝试进行一次有风险的Minor GC
        - 小于，Full GC
      - 不允许， Full GC
- 老年代进行担保，但无法知道完成内存回收时有多少对象存活，
  所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代剩余空间做比较，决定是否进行Full GC腾出老年代空间
  - 取平均值仍是一种动态概率手段，如果某次Minor GC存活的对象增加，可能会导致担保失败，只好在失败后重新发起一次Full GC

## 类加载机制

### 类的生命周期

#### 加载

- 虚拟机规范并没有强制约束，由虚拟机的具体实现来自由把握
- 过程
  - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 从ZIP包读取，如JAR、WAR等
    - 从网络获取
    - 运行时计算生成，如动态代理技术，反射等
    - 其他文件生成，如JSP
    - 从数据库读取
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据访问的入口
  - 相比其他阶段，一个非数组类的加载阶段是开发人员可控性最强的，可以自定义类加载器，其余阶段完全由虚拟机主导和控制

#### 连接

##### 验证

* 过程
  * 文件格式验证
    - 是否符合Class文件格式的规范
    - 经过验证后字节流进入方法区存储，后面的3个验证基于方法区的存储结构，不再操作字节流
  * 元数据验证
    - 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求
  * 字节码验证
    - 通过数据流和控制流分析，对类的方法体进行校验分析，确定程序语义是合法符合逻辑的，保证被校验类的方法在运行时不会做危害虚拟机安全的事件
  * 符号引用验证
    - 对类自身以外的信息进行匹配性校验，保证解析动作能正常进行
    - 发生时间
      - 虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段--解析发生

##### 准备

- 过程
  - 正式为类变量分配内存并设置类变量初始值，这些变量所使用的内存都在方法区进行分配
    - 仅包括static类变量，不包括实例变量
    - 初始值“通常情况下”是数据类型的零值，赋值操作是在初始化阶段执行
      - 如果被final修饰，会直接赋值

##### 解析

- 某些阶段可在初始化阶段后开始，为了支持动态绑定
- 过程：虚拟机将常量池内的符号引用替换为直接引用的过程
- 引用类型：
  - 符号引用
    - 以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时能无歧义地定位到目标即可
    - 与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中
    - 各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式必须明确定义在Java虚拟机规范的Class文件中
  - 直接引用
    - 可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄
    - 与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同
    - 如果有了直接引用，那引用的目标必定已经在内存中
- 解析的符号引用
  - 类或接口
  - 字段
  - 类方法
  - 接口方法
  - 方法类型
  - 方法句柄
  - 调用点限定符

#### 初始化

- 虚拟机制定的规范
  - 遇到new、getstatic、putstatic或invokestatic这4条字节码指令，如果类没有初始化，则需要先触发初始化
  - 对类进行反射调用的时候
  - 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
  - 当虚拟机启动时，用户需要制定一个要执行的主类(包含mian方法)，虚拟机会先初始化该类
  - 使用JDK1.7的动态语言支持时，如果一个MethodHandle实例最后的解析结果是某些句柄，
    并且这个句柄对应的类没有进行初始化，则先触发初始化
- 过程
  - 该阶段才真正开始执行类中定义的Java程序代码(或者说字节码)
  - 初始化阶段是执行类构造器<clinit>()方法的过程
    - <clinit>()方法是由编译期自动收集类中的所有类变量的赋值动作和静态语句块的语句合并而成，收集顺序由源文件的顺序决定
      1. 静态语句块只能访问到之前的变量
      2. 定义在静态语句块后的变量，只能赋值，不能访问
    - <clinit>()方法与类的构造函数不同，它不需要显示调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕
    - 由于父类的<clinit>()方法先执行，意味着父类定义的静态语句块要优先于子类的变量赋值操作
    - <clinit>()方法不是必需的，如果一个类没有静态语句块，也没有对变量的赋值操作，编译期可以不生成该方法
    - 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口也会生成该方法
      1. 与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，只有当父接口定义的变量使用时，父接口才会初始化
      2. 接口的实现类在初始化时也一样不会执行接口的<clinit>()方法
    - 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化，那么只有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待

#### 使用

#### 卸载

### 类加载器

#### 类与类加载器

- 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性
- 每一个类加载器，都拥有一个独立的类名称空间
  - 比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则及时两个类来源同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必不等同

#### 双亲委派模型

- 分类
  - 从Java虚拟机的角度
    - 启动类加载器(Bootstrap ClassLoader)，由C++实现
    - 其他类加载器，由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader
  - 从Java开发人员角度
    - 启动类加载器(Bootstrap ClassLoader)，由C++实现
      - 将存在JAVA_HOME/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中(仅按照名字识别，名字不符合不会加载)
      - 该加载器无法被Java程序直接引用，用户编写自定义类加载器，如需要委托给启动类加载器，直接用null替代
    - 扩展类加载器(Extension ClassLoder)
      - 负责加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库
      - 开发者可以直接使用该加载器
    - 应用程序类加载器(Application ClassLoader)
      - 也称为系统类加载器
      - 负责加载用户类路径(ClassPath)上所指定的类库
      - 开发者可以直接使用
      - 如果应用程序中没有定义自己的类加载器，默认使用该类加载器
- 工作过程
  - 如果一个类加载器接收到了类加载请求，首先它不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成
  - 所有的加载请求最终都应该传送到顶层的启动类加载器中
  - 只有当父类加载器反馈自己无法完成这个加载请求时，即它的搜索范围中没有找到所需的类，子加载器才会尝试自己去加载
- 好处
  - Java类随着它的类加载器一起具备了一种带有优先级的层次关系
    - 例如Object，无论哪个类加载器要加载，最终都是委派给最顶端的启动类加载器，保证Object类在各种类加载器中都是同一个类
- 自定义类加载器
  - 不提倡用户再去覆盖loadClass()方法
  - 把自己的类的加载逻辑写到findClass()中，如果loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法
- 破坏情况
  - 双亲委派模型出现之前，即JDK1.2之前
  - 该模型自身的缺陷导致的
    - 该模型很好地解决了各个类加载器的基础类的统一问题，因为基础类总是作为被用户代码调用的API，但如果基础类又要调用回用户代码，怎么办？
    - 例子
      - JNDI服务
  - 用户对程序动态性的追求，如代码热替换，模块热部署
    - OSGI
    - Java1.9模块化，和这个有关系吗？
- 关系
  - 除了顶层的启动类加载器，其余的类加载器都应当有自己的父类加载器
  - 父子关系不会以继承的关系来实现，而是都使用组合关系来复用父类加载器的代码



## 虚拟机字节码执行引擎

### 运行时栈帧结构(Java虚拟机栈)

##### 概述

- 支持虚拟机进行方法调用和方法执行的数据结构
- 是虚拟机运行的虚拟机栈的栈元素
- 每一个方法从调用到执行完成的过程，都对应这一个栈帧在虚拟机栈里面入栈出栈的过程
- 编译程序代码时，栈帧的结构及内存已经完全确定，并且写入到方法表的Code属性中，不会受到程序运行期变量数据的影响，仅取决于具体的虚拟机实现
- 一个线程中方法调用链可能很长，对于执行引擎来说，只有活动线程栈顶的栈帧才是有效的，执行引擎运行的所有字节码指令都只对当前栈帧进行操作

##### 结构

###### 局部变量表

- 概述
  - 一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量
  - 编译时写入到Code属性的max_locals
- 结构
  - 容量以变量槽Slot为最小单位
    - 虚拟机规范指导以下8种数据类型都可以使用32位或更小的物理内存来存放
      - boolean
      - byte
      - char
      - short
      - int
      - float
      - reference
        - 表示一个对象实例的引用
        - 从此引用中直接或间接地查找到对象在Java堆中数据存放的起始地址索引
        - 从引用中直接或间接地找到对象所属数据类型在方法区中存储的数据类型
      - returnAddress
        - 为字节码指令jsr、jsr_w、ret服务，指向了一条字节码指令的地址
        - 很少见
    - 对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间
      - long
      - double
      - reference
    - 虚拟机通过索引定位的方式使用局部变量表
      - 索引n代表第n个Slot
      - 对于64位数据类型，则说明会同时使用n和n+1两个Slot，不允许单独访问任意一个
- 方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程
  - 实例方法，第0位索引默认是传递方法所属的对象实例引用，即this，其余参数按顺序排列
  - Slot是可以重用的，当变量的作用域没覆盖整个方法体，而当前字节码的PC计数器已经超过了某个变量的作用域
  - 不存在类变量的初始化赋值

###### 操作栈

- 概述
  - 后入先出栈
  - 编译时写入到Code属性的max_stacks
  - 每一个元素可以是任意的Java数据类型
    - 32位的栈容量为1
    - 64位栈容量为2
  - 数据类型必须与字节码指令的序列严格匹配
- 理论上，两个栈帧是相互独立的，实际上会做一些优化处理，两个栈帧会出现部分操作数栈和部分局部变量表重叠，在进行方法调用时可以共用一部分数据，无须额外的参数复制传递

###### 动态连接

- 概述
  - 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接
  - Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符合引用作为参数
    - 这些符号引用一部分会在类加载阶段或者第一次使用时就转化为直接引用，称为静态解析
    - 另外一部分将在每一次运行期间转化为直接引用，称为动态连接

###### 返回地址

- 方法开始执行后退出的方式
  - 执行引擎遇到任意一个方法返回的字节码指令，这时可能会有返回值传递给上次的方法调用者，称为正常完成出口
  - 方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，就会以异常完成出口的方式退出，不会给上层调用者返回值
- 概述
  - 方法退出后，需要返回到方法被调用的位置，程序才能继续执行，因此需要在栈帧保存一些信息，用来帮助恢复它的上层方法的执行状态
  - 一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧很可能会保存这个计数器值
  - 方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧一般不会保存这部分信息
- 方法退出的操作
  - 恢复上层方法的局部变量表和操作数栈
  - 把返回值(如果有的话)压入调用者栈帧的操作数栈中
  - 调用PC计数器的值以指向方法调用指令后面的一条指令

###### 附加信息

- 虚拟机规范运行具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息
- 实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息



### 方法调用

#### 概述

- 不等同于方法执行
- 唯一任务就是确定被调用方法的版本，暂时还不设计方法内部的具体运行过程
- 需要在类加载期间，甚至到运行期间通过方法调用来确定目标方法的直接引用
  - 一切方法调用在Class文件里面存储的都是符号引用，而不是方法在实际运行时内存布局的入口地址(相当于直接引用)
  - 这个特性给Java带来了更强大的动态扩展能力

#### 解析类别

##### 概述

- 所有方法调用的目标方法在Class文件里面都是一个常量池的符号引用，在类加载的解析阶段，会将其中一部分的符号引用转为直接引用
- 调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用就称为解析
- 能被解析调用的方法都是非虚方法，其他都是虚方法

##### 符合"编译期克制，运行期不可变"的方法

- 不可能通过继承或别的方式重写其它版本，因此适合在类加载阶段进行解析
  - 静态方法
  - 私有方法

#### 分派类别

##### 分类

###### 静态分派

- 概述
  - 所有根据静态类型来定位方法执行版本的分派动作
  - 典型应用是方法重载
    - 虚拟机重载时是通过参数的静态类型而不是实际类型作为判定依据
    - 编译器会根据参数的静态类型选择使用哪个重载版本
    - 编译器虽然能确定出方法的重载版本，但很多情况下方法的重载版本并不是唯一的，而是更适合的
      1. 字面量不需要定义，因此没有显式的静态类型，只能通过语言上的规则去理解和推断
      2. 字面量’a‘，按照char>int>long>float>double>Character(自动装箱)>Serializable/Comparable(Character实现的接口)>Object>char...(可变长参数)选择重载类型
  - 发生在编译阶段，因此静态分派的动作实际上不是由虚拟机来执行的
  - 静态方法也会在类加载期去解析，而静态方法显然也是可以拥有重载版本的，选择重载版本也是通过静态分派完成
- 类型
  - Human human = new Man()
  - 静态类型
    - Human为静态类型
    - 静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型在编译时是可知的
      - human = new Women()
  - 实际类型
    - Man是实际类型
    - 实际类型的变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型
      - (Women) human

###### 动态分派

- 概述
  - 典型应用是重写
  - 无法再用静态类型来决定
  - 运行期根据实际类型确定方法执行版本的分派过程
- invokevirtual的多态查找过程
  - 找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C
    - 第一步就是在运行期确定接收者的实际类型，把常量池中的类方法符号解析到不同的直接引用上，这个过程是Java重写的本质
  - 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接亦用，查找过程结束；如果校验不通过，抛IllegalAccessError异常
  - 否则，按照继承关系从下往上依此对C的各个父类进行第2步的搜索和验证过程
  - 如果始终没有找到合适的方法，则抛出AbstractMethodError异常

###### 单分派和多分派

- 宗量
  - 方法的接收者和方法的参数统称为方法的宗量

- 单分派
  - 概述: 根据一个宗量对目标方法进行选择

- 多分派
  - 概述: 根据多于一个宗量对目标方法进行选择

- 示例代码：

  ``` java
  public class Dispatch{
  
      static class QQ{}
  
      static class_360{}
  
      public static class Father{
  
          public void hardChoice（QQ arg）{
  
              System.out.println（"father choose qq"）；
  
          }
  
          public void hardChoice（_360 arg）{
  
              System.out.println（"father choose 360"）；
  
          }
  
      }
  
      public static class Son extends Father{
  
          public void hardChoice（QQ arg）{
  
              System.out.println（"son choose qq"）；
  
          }
  
          public void hardChoice（_360 arg）{
  
              System.out.println（"son choose 360"）；
  
          }
  
      }
  
      public static void main（String[]args）{
  
          Father father=new Father（）；
  
          Father son=new Son（）；
  
          father.hardChoice（new_360（））；
  
          son.hardChoice（new QQ（））；
  
      }
  
  }
  
  运行结果：
  
  father choose 360
  
  son choose qq
  ```

  * 编译阶段的选择过程
    * 选择目标方法的依据
      1. 静态类型是Father还是Son
      2. 方法参数是QQ还是360
    * 两个方法生成的两条指令分别为常量指向Father.hardChoice(360)和Father.hardChoice(QQ)方法的符合引用
    * Java语言的静态分派属于多分派类型
  * 运行结点的选择过程
    * 选择目标方法的依据
      1. 已经确定静态类型是Father
      2. 执行son.hardChoice(new QQ())时，这时参数的静态类型、实际类型都对方法的选择不会有影响
      3. 唯一可以影响虚拟机的因素是此方法接受者的实际类型是Father还是Son
  * Java语言的动态分派属于单分派类型

###### **今天的Java语言是静态多分派、动态单分派语言 **

###### 以上类型可以两两组合，如静态多分派

##### 虚拟机动态分派的实现

###### 虚方法表

- 原因
  - 动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，需要进行性能上的优化
  - 使用虚方法表来代替元数据索引以提高性能
- 结构
  - 关系
  - 虚方法表中存放着各个方法的实际入口地址
  - 如果某个方法在子类中没有被重写，那么子类在虚方法表里面的的入口地址和父类的一致，都指向父类的实现入口
  - 如果子类重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址
  - 为了程序上的实现方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有相同的索引号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址
- 时机
  - 方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕
- 位置
  - 方法区中建立一个虚方法表
- 其他
  - 于此对应，invokeinterface执行时也会用到接口方法表

###### 内联缓存

- 非稳定的"激进优化"

###### 基于"类型继承关系分析"技术的守护内联

- 非稳定的"激进优化"

#### 虚拟机提供的方法调用字节码指令

##### invokestatic：调用静态方法

##### invokespecial：调用实例构造器方法、私有方法和父类方法

##### invokevirtual：调用所有的虚方法、final方法

##### invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象

##### invokedynamic

- 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法
- 其它调用指令，分配逻辑是固化在Java虚拟机内部的，而该指令的分派逻辑是由用户所设定的引导方法决定的



### 动态语言类型支持

### 基于栈的字节码解释执行引擎

- 解释执行
- 基于栈的指令集
  - 优点
    - 可移植
    - 代码相对更加紧凑
    - 编译器实现更加简单
  - 缺点
    - 执行速度相对较慢
  - 基于栈的解释器的执行过程
    - http://chenzhou123520.iteye.com/blog/1607270
- 基于寄存器的指令集





## 程序编译与代码优化

### 编译器

#### 前端编译器

- 把java文件转换成class文件
- Sun的Javac，Eclipse JDT的增量式编译器(ECJ)

#### 后端运行器编译器(JIT, Just In Time Compiler)

- Java程序最初是通过解释器解释执行，当虚拟机发现某个方法或者代码块运行的特别频繁时，就会把这些代码认定为"热点代码"
- 为了提高热点代码的执行效率，运行时，虚拟机会把字节码转变成与本地平台相关的机器码，并进行各种层次的优化
- 并不是虚拟机的必须部分，规范没有规定，也没有指导
- HotSpot VM的C1、C2编译器

#### 静态提前编译器(AOT，Ahead Of Time Compiler)

- CNU Complier for the Java(GCJ)
- Excelsior JET



### 早期(编译期)优化

#### Javac编译器

##### 过程

###### 解析与填充符号表

- 词法分析
  - 将源代码的字符流转变为Token集合，单个字符是程序编写过程的最小元素，而Token是编译过程的最小元素
- 语法分析
  - 根据Token序列构造抽象语法树的过程，抽象语法树(AST)是一种用来描述程序代码语法结构的树形标识方式
  - 语法树的每个节点都代表程序代码中的一个语法结构
- 填充符号表
  - 符号表是由一组符号地址和符号信息构成的表格
    - 哈希表
    - 有序符号表
    - 树状符号表
    - 栈结构符号表
  - 符号表中所登记的信息在不同阶段都要用到
    - 在语义分析中，符号表等级的内容将用于语义检查和产生中间代码
      - 如检查一个名字的使用与原形的说明是否一致
    - 在目标代码生成阶段，当对符号表进行地址分配时，符号表是地址分配的依据
  - 此过程的出口是一个待处理列表，包含了每一个编译单元的抽象语法树的顶级节点、以及pacakge-info.java(如果存在)的顶级结点

###### 插入式注解处理器的注解处理

- JDK1.6实现的JSR-269规范提供一组插入式注解处理器的标准API在编译期间对注解进行处理
- 该处理器可看作一组编译器的插件
  - 在这些插件里，可以读取、修改、添加抽象语法树中的任意元素
  - 如果在处理期间对抽象语法树进行修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器不再对AST进行修改

###### 语义分析与字节码生成

- 标注检查
  - 检查内容
    - 变量使用前是否已被声明
    - 变量与赋值之间的数据类型是否匹配
    - 常量重叠
      - int a = 1 + 2，会被重叠为int a = 3
    - ...
- 数据流及控制流分析
  - 对程序上下文逻辑更进一步验证
    - 程序局部变量在使用前是否有赋值
    - 方法的每条路径是否有返回值
    - 所有的受查异常是否被正确处理
    - ...
  - 目的与类加载的数据及控制流分析基本一致，但校验范围有区别，有一些校验项只有在编译器或运行期才能执行
    - final语义校验
      - 局部变量定义为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障
- 解语法糖
- 字节码生成
  - 把前面各个步骤所生成的信息转换成字节码写到磁盘中
  - 进行了少量代码添加和转换工作
    - 把实例构造器和类构造器添加到AST
      - 实例构造器并不是指默认构造函数，如果程序中没有构造函数，编译器会添加一个没有参数、访问性与当前类一直的默认构造函数，这个工作在填充符号表阶段完成
      - 实际上是一个代码收敛过程，编译器把语法块(实例构造器为{}，类构造器为static{})、变量初始化、调用父类的实例构造器(<client>()无须调用父类构造器，虚拟机会自动保证父类构造器的执行)等操作
        收敛到<init>()和<client>()方法之中，并且保证先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序执行
    - 字符串的加操作替换为StringBuffer或StringBuilder的append操作
    - ...

- 关系

#### Java语法糖

- 泛型与类型擦除
  - 泛型只在程序源码中存在，在编译后的字节码文件中，就已经被替换为原来的原生类型，并且在相应的地方插入了强制转型代码
  - 对运行期的Java语言来说，ArrayList<int>和ArrayList<str>就是同一个类
    - 可能会导致无法重载
- 自动拆箱、装箱与循环遍历
- 条件编译
  - 条件为常量的if语句
    - 编译器会将分支中不成立的代码块消除掉



### 晚期(运行期)优化

#### HotSpot虚拟机内的即时编译器

##### 编译器与解释器

- 概述
  - 不是所有的虚拟机都采用编译器和解释器并存的架构
  - 当程序需要首次执行的时候，解释器可以首先发挥作用，省去编译时间，立即执行
  - 在程序运行后，随着时间推移，编译器逐渐发挥作用，把更多的代码编译成本地代码，获得更高的执行效率
  - 当程序运行环境中内存资源限制较大可以使用解释执行节约内存，反之可以使用编译执行提高效率
  - 解释器还可以作为编译器激进优化的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段,
    当激进优化的假设不成立，如加载了新类后类型继承结构出现变换，出现"罕见陷阱"是可以通过逆优化退回到解释状态继续执行
    - 部分没有解释器的虚拟机也不会采用不进行激进优化得Client Complier编译器担任逃生门
  - 关系

##### HotSpot内置的即时编译器

- 分类
  - Client Compiler，即C1编译器
  - Server Compiler，即C2编译器
- 默认采用解释器与其中一个编译器直接配合的方式，选择哪个编译器取决于虚拟机运行的模式
- JIT编译代码要占用程序运行时间；要编译出优化程度更高的代码，花费的时间可能更长，
  解释器可能还要替编译器收集性能监控信息，对解释器的速度也有影响
- 分层编译策略
  - 目的：在程序启动与运行效率达到平衡
  - 时机：JDK1.6出现，在JDK1.7的Server模式作为默认编译策略
  - 根据编译器编译、优化的规范与耗时、划分的不同编译层次
    - 第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译
    - 第1层，也称为C1编译，将字节码编译成本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑
    - 第2层或2层以上，即C2编译，也就是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化
  - 实现分层编译后，C1和C2将会同时工作，许多代码都可能会被多次编译，用C1获取更高的编译速度，用C2来获取更好的编译质量，在解释执行也无须再承担收集性能监控信息的任务

##### 编译对象与触发条件

- 编译对象
  - 被多次调用的方法
  - 对多次执行的循环体
- 热点探测判定方式
  - 基于采样的热点探测
    - 虚拟机会周期性的检查各个线程的栈顶
  - 基于计数器的热点探测
    - 为每个方法建立计数器，统计方法执行的次数
- HotSpot基于计数器的热点探测
  - 方法调用计数器
    - 并不是方法调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数
      - 当超过一定时间限度，调用次数不达标，这个方法的调用计数器将会衰减一半
    - 过程
  - 回边计数器
    - 统计一个方法中循环体代码执行的次数，准确的说，是回边的次数，并非所有的循环都是回边，比如空循环
    - 过程

#### 编译优化技术

##### 公共子表达式消除

##### 数组边界检查消除

##### 方法内联

##### 逃逸分析

- 证明一个对象不会逃逸到方法或线程外，可以为该对象使用更高效的优化
  - 栈上分配
  - 同步消除
  - 标量替换

#### 与C/C++静态编译器对比

- 相对劣势
  - JIT占用的是用户程序的运行时间，具有很大的时间压力，优化的手段也严重受制于编译成本
  - Java语言是动态的类型安全语言，需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存。从实现层面看，需要频繁的进行动态检查，总体上消耗时间
  - Java语言虽然没有virtual关键字，但使用虚方法的频率远远大于C/C++语言，意味着运行时对方法接收者进行多态选择的频率要高，意味着JIT在一些优化上更难
  - Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，使得全局优化难进行，都只能以激进优化的方式来完成，
    编译器需要时刻注意并随着类型的变换在运行时撤销或重新进行优化
  - Java语言中对象的内存分配都是在堆上进行，只有方法的局部变量才能在栈上分配。而C++则有多种内存分配方式，并且由程序代码控制，减轻内存回收压力
- 相对优势
  - 换取开发效率上的优势
  - 某些优化是C++编译器不能做到的
    - 别名分析
  - C++无法做到运行期性能监控为基础的优化措施



## Java内存模型

### 概述

* 屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果
* 没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制JIT进行调整代码执行顺序这类优化措施
* 目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节
  - 与编程中的变量不同，包括了实例字段、静态字段和构成数组对象的元素
  - **不包括局部变量与方法参数，因为是线程私有的，不会被共享也就不会有竞争问题**

### 结构

- 所有的变量必须存储在主内存
- 每条线程有自己的工作内存
  - 线程的工作内存保存了被该线程使用到的变量的主内存拷贝
  - 线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存的变量
- 不同的线程之间也无法直接访问对方工作内存中的变量
  - 线程间变量值的传递均需要通过主内存
- 关系图
- **内存模型与Java内存区域的Java堆、栈等并不是一个同层次的内存划分，基本上没有关系**
  - **如果强硬划分，主内存对应Java堆中的对象实例部分，工作内存则对应虚拟机栈中的部分区域**
  - 更低层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储与寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存

### 内存间交互操作

#### Java内存模型定义的8种操作

- lock：锁定。作用于主内存的变量，把一个变量标识为一条线程独占的状态
- unlock：解锁。与lock相反，释放后的变量才可以被其他线程锁定
- read：读取。作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存，便于后续load
- load：载入。作用于工作内存的变量，把read操作得到的变量值放入到工作内存的副本中
- use：使用。作用于工作内存的变量，把工作内存的一个变量值传递给执行引擎
  - 每当虚拟机遇到一个需要使用到的变量的值的字节码指令就会执行这个操作
- assign：赋值。作用于工作内存的变量，把一个执行引擎接收到的值赋值给工作内存的变量
  - 每当虚拟机遇到一个需要使用给变量赋值的字节码指令就会执行这个操作
- store：存储。作用于工作内存的变量，把工作内存的一个变量值传送到主内存中，以便后续write
- write：写入。作用于主内存的变量，把store操作从工作内存中得到的变量值放入主内存
- 每一种操作都是原子性、不可分割的，对double、long来说，load、store、read和write可能有例外
- **最新JSR-133文档，已经放弃采用这8种操作去定义Java内存模型的访问协议(仅仅是描述方式改变，内存模型并没有改变)**

#### Java内存模型操作的规则

- 不允许read和load、store和write操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。
- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
- 如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。

#### Volatile型变量的特殊规则

- 概述：最轻量级的同步机制
- 特性
  - 保证此变量对所有线程的可见性
    - 一条线程修改了这个变量的值，新值对于其他线程来说是立即可见的。
      - 并不等同于Volatile变量是并发安全的，可能对该变量的操作不是原子操作
    - 需要注意，volatile变量的写操作除了对它本身的读操作可见外，volatile写操作之前的所有共享变量均对volatile读操作之后的操作可见，另外注意其适用场景
  - 禁止指令重排序优化(通过加入指令内存屏障方式)
    - 普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得正确的结果，而不能保证变量赋值操作的顺序与程序中的执行顺序一致，在单线程中，我们是无法感知这一点的。
- 需要加锁保证原子性的运算场景
  - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
  - 变量不需要与其他的状态变量共同参与不变约束
- 指令重排序
  - Java语言规范规定了JVM线程内部维持顺序化语义，也就是说只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致，这个过程通过叫做指令的重排序。
  - 意义：JVM能够根据处理器的特性（CPU的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整
- 特殊规则
  - 线程T对变量V的load、read动作相关联，必须连续一起出现
  - 线程T对变量V的store、write动作相关联，必须连续一起出现
  - ...

#### long和double的特殊规则

- 规范运行虚拟机将没有被volitate修饰的64位数据的读写操作划分为两次32位操作，即虚拟机可以选择不保证64位数据类型的load、store、read和write这4个操作的原子性
  - 多线程下可能会出现半个变量值有误的情况

### 三大特征

#### 原子性

- 基本数据类型的访问读写
- 同步块，即synchronized

#### 可见性

- Volitate
- Synchronized
- final

#### 有序性

- Volitate
- Synchronized
- Java程序中天然的有序性总结
  - 如果在本线程内观察，所有的操作都是有序地
    - 指线程内表现为串行的语义
  - 如果在一个线程中观察另一个线程，所有的操作都是无序的
    - 指“指令重排序”和“工作内存与主内存同步延迟的现象”



### 先行发生原则

#### 定义

- 先行发生是java内存模型中定义的两项做错之间的偏序关系，如果说操作A先行发生与操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。
- Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

#### 分类

- 程序次序规则
  - 在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作，准确的说，应该是控制流程序而不是程序代码顺序，因为要考虑分支、循环等结构；
- 管程锁规则
  - 一个unlock操作先行发生于后面对同一个锁的lock操作，这里必须强调的是同一个锁，“后面”指的是时间上的先后顺序
- Volatile变量规则
  - 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，“后面”同样是时间上的先后顺序
- 线程启动规则
  - Thread对象的start()方法先行发生于次线程的每一个动作
- 线程终止规则
  - 线程中的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束，Thread.isAlive()的返回值等手段检测到线程已终止执行
- 线程中断规则
  - 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interruptd()方法检测到是否有中断发生
- 对象终结规则
  - 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始
- 传递性
  - 如果操作A先行发生于操作B，操作B先行发生于操作C，那么就可以认为操作A先行发生于操作C



## Java线程

- 实现：在Windows和Linux上，使用一对一模型映射到到一条系统的轻量级进程

- 线程调度方式

  - 协同式线程调度
    - 线程的执行时间由线程来控制
  - 抢占式线程调度
    - 每个线程由系统来分配时间

  - **Java线程是通过映射到系统原生线程，调度最终还是取决与操作系统**

- 线程状态转换图

## 线程安全与锁优化

### 线程安全定义

当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的

### Java语言中的共享数据的操作

#### 不可变：不可变的对象一定是线程安全的

- final 修饰
- String
- 枚举类型
- Number的部分子类

#### 绝对线程安全

* 满足线程安全的定义

* Java很多标准自己是线程安全的类，大多数都不是绝对的线程安全，可能要额外加入一定的同步措施

  * **线程安全的类，方法是线程安全的，但使用不规范可能导致线程不安全**

  ``` java
  // 对线程安全的容器 Vector的测试
  
  public class VectorTest {
  
      private static Vector<Integer> vector = new Vector<>(); 
  
      
  
      public static void main(String[] args) {
  
          while(true) {
  
              for (int i = 0; i < 100; i++) {
  
                  vector.add(i);
  
              }
  
              
  
              Thread removeThread = new Thread(new Runnable() {
  
                  @Override
  
                  public void run() {
  
                      for (int i = 0; i < vector.size(); i++) {
  
                          vector.remove(i);
  
                      }
  
                  }
  
              });
  
              
  
              Thread printThread = new Thread(new Runnable() {
  
                  @Override
  
                  public void run() {
  
                      for (int i = 0; i < vector.size(); i++) {
  
                          System.out.println(vector.get(i));
  
                      }
  
                  }
  
              });
  
              
  
              removeThread.start();
  
              printThread.start();
  
              
  
              // 不要同时产生过多的线程，否则会导致os 假死
  
              while(Thread.activeCount() > 20);
  
          }
  
      }
  
  }
  
  运行结果会抛ArrayIndexOutOfBoundsException
  假如printThread进入到System.out.println(vector.get(i))转为就绪状态，removeThread把所有元素删除，就会报该异常。
  ```

#### 相对线程安全

* 通常意义上所讲的线程安全，它需要保证这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性

  ``` java
  // 对线程安全的容器 Vector的测试(修改后的代码)
  
  public class ModifiedVectorTest {
  
      private static Vector<Integer> vector = new Vector<>(); 
  
      
  
      public static void main(String[] args) {
  
          while(true) {
  
              for (int i = 0; i < 100; i++) {
  
                  vector.add(i);
  
              }
  
              
  
              Thread removeThread = new Thread(new Runnable() {
  
                  @Override
  
                  public void run() {
  
                      synchronized (vector) { // 添加同步块，this line
  
                          for (int i = 0; i < vector.size(); i++) {
  
                              vector.remove(i);
  
                          }
  
                      }
  
                  }
  
              });
  
              
  
              Thread printThread = new Thread(new Runnable() {
  
                  @Override
  
                  public void run() {
  
                      synchronized (vector) { // 添加同步块，this line
  
                          for (int i = 0; i < vector.size(); i++) {
  
                              System.out.println(vector.get(i));
  
                          }
  
                      }
  
                  }
  
              });
  
              
  
              removeThread.start();
  
              printThread.start();
  
              
  
              // 不要同时产生过多的线程，否则会导致os 假死
  
              while(Thread.activeCount() > 20);
  
          }
  
      }
  
  }
  ```

#### 线程兼容

* 指对象本身并不是线程安全的，但是可以通过调用端正确地使用同步手段来保证对象在并发环境中安全的使用
  * Java大部分的类都是线程兼容，如Vector、HashTable相对应的集合类ArrayList、HashMap等

#### 线程对立

- 指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码
- 这种代码很少出现，而且通常有害，应当尽量避免
  - Thread类的suspend和resume

### 线程安全的实现方法

#### 互斥同步(悲观锁)

##### 概述

- 常见的一种并发正确性保障手段
- 同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个(或者是一些，使用信号量的时候)线程使用。
- 互斥是实现同步的一种手段
  - 临界区
  - 互斥量
  - 信号量
- 进行线程阻塞或唤醒会带来的性能问题，因此这种同步也称为阻塞同步
- 从处理问题的方式上说，属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那肯定会出现问题
  - 无论共享数据是否会出现竞争，它都要进行加锁、用户态核心转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作

##### 方法

###### synchronized关键字

* 使用方式
  * **修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁**
  * **修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁** 。
    - 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。
    - 所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。
  * **修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。** 
    - 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。
    - 这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。
    - 另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！

* 示例：单例模式

  ``` java
  public class Singleton {
  
      private volatile static Singleton uniqueInstance;
  
      private Singleton() {
      }
  
      public static Singleton getUniqueInstance() {
         //先判断对象是否已经实例过，没有实例化过才进入加锁代码
          if (uniqueInstance == null) {
              //类对象加锁
              synchronized (Singleton.class) {
                  if (uniqueInstance == null) {
                      uniqueInstance = new Singleton();
                  }
              }
          }
          return uniqueInstance;
      }
  }
  ```

  * uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行，这可能会导致指令重排序而其他线程获得还没初始化的实例
    * 为 uniqueInstance 分配内存空间
    * 初始化 uniqueInstance
    * 将 uniqueInstance 指向分配的内存地址

* 底层原理

  * **synchronized 同步语句块**：使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置
  * **synchronized 修饰方法**： 没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法

* JDK1.6后的优化

  * 在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 **偏向锁** 和 **轻量级锁** 以及其它**各种优化**之后变得在某些情况下并不是那么重了。
  * synchronized的底层实现主要依靠 **Lock-Free** 的队列，基本思路是 **自旋后阻塞**，**竞争切换后继续竞争锁**，**稍微牺牲了公平性，但获得了高吞吐量**。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。

###### 重入锁ReentrantLock

- 相比synchronized增加的高级功能
  - **等待可中断**
    - 指当前持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情
    - 对处理执行时间非常长的同步块很有帮助
  - **可实现公平锁**
    - 多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依此获得锁，非公平锁不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁
    - Synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁
  - **锁可以绑定多个条件**
    - 指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的notify、wait和notifyAll方法可以实现一个隐含的条件，如果要和多于一个的条件关联，就不得不额外的添加一个锁，而ReentrantLock则无需这样做，只需要多次调用newCondition()方法
- 对比
  - **两者都是可重入锁**
  - **synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API**
  - **性能已不是选择标准**
    - **JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。**
    - **虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步**

#### 非阻塞同步(乐观锁)

##### 概述

- 基于冲突检测的乐观并发策略
- 先进行操作，如果没有其它线程争用共享数据，那操作成功；如果有冲突，那就采取其他补偿措施(不断地重试)
- 很多实现都不需要把线程挂起
- 需要硬件指令集的发展，保证一个语义看起来需要很多次的操作只通过一条指令执行
  - 测试并设置
  - 获取并增加
  - 交换
  - 比较并交换（Compare-and-Swap，CAS）
  - 加载链接/条件存储(Load-Linked/Store-Conditional，LL/SC)

##### 方法

###### 版本号机制

* 一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

######  CAS操作

* CAS算法涉及到三个操作数

  - 需要读写的内存值 V
  - 进行比较的值 A
  - 拟写入的新值 B

  当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。

* 一般情况下是一个**自旋操作**，即**不断的重试**。

* 缺点

  *  ABA 问题：一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。

    *  使用AtomicStampedReference，相当于加入了版本号机制
  *  循环时间长开销大：自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销

    *  JVM会将锁升级
  *  只能保证一个共享变量的原子操作：CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。
     *  从 JDK 1.5开始，提供了`AtomicReference类`来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.

* 使用场景：**适用于写比较少的情况下（多读场景，冲突一般较少）**

  * 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
  * 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。

* 使用CAS的Atomic 原子类

  * AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。

#### 无同步方案

##### 概述

- 保证线程安全，不一定需要同步，两者没有因果关系
- 同步只是保证共享数据争时的正确性收到，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因为有一些代码天生就是安全的

##### 分类

###### 可重入代码Reentrant Code

- 概述
  - 可以在代码执行的任何时刻中断它，转而去执行另一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误
  - 相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入代码都是线程安全的，但是并非所有的线程安全代码都是可重入的
- 特征
  - 不依赖存储在堆上的数据和公用的系统资源
  - 用到的状态量都由参数传入
  - 不调用非可重入的方法
- 判断代码是否具有可重入性
  - 如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性的要求，也就是线程安全的

###### 线程本地存储(Thread Local Storage)

- 概述
  - 共享数据的代码保证在同一个线程执行，把共享数据的可见范围限制在同一个线程内
- 符合的应用
  - 大部分使用消费队列的架构模式
  - Web交互模型中的“一个请求对应一个服务器线程”
- 方法
  - ThreadLocal



### 锁优化

#### 自旋锁和自适应自旋

- 概述
  - 共享数据的锁定状态只会持续一段时间，而为这段时间去挂起或恢复线程并不值得
  - 如果物理机器有一个以上的处理器，可以让请求的线程稍等，不放弃处理器的执行时间，看持有锁的线程是否很快就会释放锁
  - 为了让线程等待，只需让它执行一个空循环
  - 不能代替阻塞
  - 虽然避免了线程切换的开销，但要占用处理器时间，如果锁被占用的时间很长，会浪费资源，因此等待的时间要有一定限度
- JDK1.6引入了自适应的自旋锁，自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者状态决定

#### 锁消除

- 概述
  - JIT运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除
- 判断依据
  - 来源于逃逸分析的数据支持

#### 锁粗化

- 如果一系列的连续操作都对一个对象反复加锁解锁，甚至是出现在循环体中，即使没有线程竞争，也会出现不必要的性能消耗
- 虚拟机探测到有这样一系列操作，就会把加锁同步的范围扩展粗化到整个操作序列的外部

#### 轻量级锁

- 概述
  - JDK1.6后引进
  - 轻量级是相对使用操作系统互斥量来实现的传统锁而言
  - 并不是用来代替重量级锁，本意是在没有多线程竞争的前提下，减少传统的重量级锁带来的性能消耗
  - 加锁解锁通过CAS操作来进行
  - 因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于重量级锁这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。
- 能提升同步性能的依据
  - 对于绝大部分的锁，在整个同步期间内都是不存在竞争的
    - 如果没有竞争，使用CAS避免了使用互斥量的开销
    - 如果有竞争，除了互斥量的开销，还额外发生了CAS，会比传统重量锁更慢

#### 偏向锁

* 偏向锁，其实是无锁竞争下可重入锁的简单实现。

> 偏向锁，简单的讲，就是在锁对象的对象头中有个ThreaddId字段，这个字段如果是空的，
> 第一次获取锁的时候，就将自身的ThreadId写入到锁的ThreadId字段内，将锁头内的是否偏向锁的状态位置1.
> 这样下次获取锁的时候，直接检查ThreadId是否和自身线程Id一致，如果一致，则认为当前线程已经获取了锁，因此不需再次获取锁，
> 略过了轻量级锁和重量级锁的加锁阶段。提高了效率。
>
> 但是偏向锁也有一个问题，就是当锁有竞争关系的时候，需要解除偏向锁，使锁进入竞争的状态。

- 目的
  - JDK1.6后引进
  - 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能
  - 如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS都不做
  - 这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他线程获得，则持有该锁的线程永远不需要在进行同步；当有另一个线程1去尝试获取该锁时，偏向模式就结束



### 锁升级过程

| 锁       | 优点                                                         | 缺点                                             | 适用场景                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------ |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。   |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。                   | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。    | 追求响应时间。同步块执行速度非常快。 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。                            | 线程阻塞，响应时间缓慢。                         | 追求吞吐量。同步块执行速度较长。     |



* 无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级

* 锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁

> 每一个线程在准备获取共享资源时： 
> 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 
> 第二步，如果MarkWord不是自己的ThreadId,锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。 
> 第三步，两个线程都把对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作，
> 把共享对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord, 
> 第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 
> 第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 
> 第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己

![](https://pic1.zhimg.com/v2-9db4211af1be81785f6cc51a58ae6054_r.jpg)

## AbstractQueuedSynchronizer(AQS)

### 概述

AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。

### 原理

#### 核心思想

​	![](https://camo.githubusercontent.com/55090fdc22963d41a3e56d5dadb17dfa7ad6379f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545352539312539382545352542462538352545352541342538372545462542432539412545352542392542362545352538462539312545372539462541352545382541462538362545372542332542422545372542422539462545362538302542422545372542422539332f434c482e706e67)

* **如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态**
* **如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**
  * CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配

### 结构

* 使用一个int成员变量state来表示同步状态，使用CAS对该同步状态进行原子操作实现对其值的修改

  ```
  private volatile int state;//共享变量，使用volatile修饰保证线程可见性
  ```

* 通过内置的FIFO队列来完成获取资源线程的排队工作

* 状态信息通过protected类型的getState，setState，compareAndSetState进行操作

  ```
  //返回同步状态的当前值
  protected final int getState() {  
          return state;
  }
   // 设置同步状态的值
  protected final void setState(int newState) { 
          state = newState;
  }
  //原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）
  protected final boolean compareAndSetState(int expect, int update) {
          return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
  }
  ```

### 资源共享方式

不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在上层已经帮我们实现好了。

**Exclusive**（独占）

* 只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁
  * 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
  * 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的

**Share**（共享）

* 多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock

#### AQS底层使用了模板方法模式

同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：

1. 使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）

   ```
   isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
   tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
   tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
   tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
   tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
   ```

2. 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

* 示例
  * 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。
  * 以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。
* 推荐两篇 AQS 原理和相关源码分析的文章：
  - <http://www.cnblogs.com/waterystone/p/4920797.html>
  - <https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html>

### Semaphore(信号量)-允许多个线程同时访问

* 指定多个线程同时访问某个资源
* 执行 `acquire` 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 `release` 方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。 Semaphore经常用于限制获取某种资源的线程数量。

``` java
public class SemaphoreExample1 {
  // 请求的数量
  private static final int threadCount = 550;

  public static void main(String[] args) throws InterruptedException {
    // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）
    ExecutorService threadPool = Executors.newFixedThreadPool(300);
    // 一次只能允许执行的线程数量。
    final Semaphore semaphore = new Semaphore(20);

    for (int i = 0; i < threadCount; i++) {
      final int threadnum = i;
      threadPool.execute(() -> {// Lambda 表达式的运用
        try {
          semaphore.acquire();// 获取一个许可，所以可运行线程数量为20/1=20
          test(threadnum);
          semaphore.release();// 释放一个许可
        } catch (InterruptedException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }

      });
    }
    threadPool.shutdown();
    System.out.println("finish");
  }

  public static void test(int threadnum) throws InterruptedException {
    Thread.sleep(1000);// 模拟请求的耗时操作
    System.out.println("threadnum:" + threadnum);
    Thread.sleep(1000);// 模拟请求的耗时操作
  }
}
```

### CountDownLatch （倒计时器）

#### 概述

一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行

#### 典型用法

* 某一线程在开始运行前等待n个线程执行完毕。将 CountDownLatch 的计数器初始化为n ：`new CountDownLatch(n) `，每当一个任务线程执行完毕，就将计数器减1 `countdownlatch.countDown()`，当计数器的值变为0时，在`CountDownLatch上 await()` 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。
* 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 `CountDownLatch` 对象，将其计数器初始化为 1 ：`new CountDownLatch(1) `，多个线程在开始执行任务前首先 `coundownlatch.await()`，当主线程调用 countDown() 时，计数器变为0，多个线程同时被唤醒。
* 死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。

#### 使用示例

``` java
public class CountDownLatchExample1 {
  // 请求的数量
  private static final int threadCount = 550;

  public static void main(String[] args) throws InterruptedException {
    // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）
    ExecutorService threadPool = Executors.newFixedThreadPool(300);
    final CountDownLatch countDownLatch = new CountDownLatch(threadCount);
    for (int i = 0; i < threadCount; i++) {
      final int threadnum = i;
      threadPool.execute(() -> {// Lambda 表达式的运用
        try {
          test(threadnum);
        } catch (InterruptedException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        } finally {
          countDownLatch.countDown();// 表示一个请求已经被完成
        }

      });
    }
    countDownLatch.await();
    threadPool.shutdown();
    System.out.println("finish");
  }

  public static void test(int threadnum) throws InterruptedException {
    Thread.sleep(1000);// 模拟请求的耗时操作
    System.out.println("threadnum:" + threadnum);
    Thread.sleep(1000);// 模拟请求的耗时操作
  }
}
```

#### 不足

CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。



### CyclicBarrier(循环栅栏)

#### 概述

* CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。
* CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活
* CyclicBarrier默认的构造方法是 `CyclicBarrier(int parties)`，其参数表示屏障拦截的线程数量，每个线程调用`await`方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。
* CyclicBarrier还提供一个更高级的构造函数`CyclicBarrier(int parties, Runnable barrierAction)`，用于在线程到达屏障时，优先执行`barrierAction`，方便处理更复杂的业务场景。

#### 应用场景

* 用于多线程计算数据，最后合并计算结果的应用场景

  * 比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的
    日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。

  

#### 使用示例

``` java
public class CyclicBarrierExample2 {
  // 请求的数量
  private static final int threadCount = 550;
  // 需要同步的线程数量
  private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5);

  public static void main(String[] args) throws InterruptedException {
    // 创建线程池
    ExecutorService threadPool = Executors.newFixedThreadPool(10);

    for (int i = 0; i < threadCount; i++) {
      final int threadNum = i;
      Thread.sleep(1000);
      threadPool.execute(() -> {
        try {
          test(threadNum);
        } catch (InterruptedException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        } catch (BrokenBarrierException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
      });
    }
    threadPool.shutdown();
  }

  public static void test(int threadnum) throws InterruptedException, BrokenBarrierException {
    System.out.println("threadnum:" + threadnum + "is ready");
    try {
      cyclicBarrier.await(2000, TimeUnit.MILLISECONDS);
    } catch (Exception e) {
      System.out.println("-----CyclicBarrierException------");
    }
    System.out.println("threadnum:" + threadnum + "is finish");
  }

}
```

### CyclicBarrier和CountDownLatch的区别

![](https://camo.githubusercontent.com/5c19d9e66ffaf3d7193b01948279db9b9b3b98d3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545352539312539382545352542462538352545352541342538372545462542432539412545352542392542362545352538462539312545372539462541352545382541462538362545372542332542422545372542422539462545362538302542422545372542422539332f4151533333332e706e67)

* CountDownLatch： 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行
* CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行

## 并发容器

### ConcurrentHashMap(线程安全的HashMap)

#### 底层实现

* JDK1.7及以前，**由 Segment(分段锁) 数组结构和 HashEntry 数组结构组成**。
  * 将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。
  * Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。
  * HashEntry 用于存储键值对数据。
  * 一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。
* JDK8及以后，取消了Segment分段锁，数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。采用CAS和synchronized来保证并发安全
  * synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。

#### 与HashTable对比

* Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
* **Hashtable(同一把锁)** :使用 synchronized 来保证线程安全，效率非常低下。对整个数据结构加锁。



### CopyOnWriteArrayList

#### 简介

``` java
public class CopyOnWriteArrayList<E>
extends Object
implements List<E>, RandomAccess, Cloneable, Serializable
```

* 读取是完全不用加锁的，写入也不会阻塞读取操作，只有写入和写入之间需要进行同步等待。

#### 工作原理

* 所有可变操作（add，set等等）都是通过创建底层数组的新副本来实现的
  * 当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本
* 写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。

#### 源码分析

##### 读取操作

* 没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。

```
    /** The array, accessed only via getArray/setArray. */
    private transient volatile Object[] array;
    public E get(int index) {
        return get(getArray(), index);
    }
    @SuppressWarnings("unchecked")
    private E get(Object[] a, int index) {
        return (E) a[index];
    }
    final Object[] getArray() {
        return array;
    }
```

##### 写入操作

* 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。

```
 /**
     * Appends the specified element to the end of this list.
     *
     * @param e element to be appended to this list
     * @return {@code true} (as specified by {@link Collection#add})
     */
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();//加锁
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);//拷贝新数组
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();//释放锁
        }
    }
```

## ConcurrentLinkedQueue，非阻塞队列

* 算是在高并发环境中性能最好的队列
* Java提供的线程安全的 Queue 可以分为**阻塞队列**和**非阻塞队列**，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue
  * **阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。**
* 使用 CAS 非阻塞算法来实现线程安全
* 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的ConcurrentLinkedQueue来替代。

## BlockingQueue，阻塞队列

#### 概述

* 阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。
* BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口

#### ArrayBlockingQueue

* BlockingQueue 接口的有界队列实现类，底层采用**数组**来实现
* 一旦创建，容量不能改变
* 并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作
* 当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。
*  默认情况下不能保证线程访问队列的公平性，可在创建时制定参数保证公平性，但通常会降低吞吐量

### LinkedBlockingQueue

* 基于**单向链表**实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足FIFO的特性
* 与ArrayBlockingQueue 相比起来具有更高的吞吐量
* 防止容量迅速增大消耗内存，创建时会指定其大小，否则容量等于Integer.MAX_VALUE。

### PriorityBlockingQueue

* 支持优先级的无界阻塞队列
* 默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 `compareTo()` 方法来指定元素排序规则，或者初始化时通过构造器参数 `Comparator` 来指定排序规则
* 并发控制采用的是 **ReentrantLock**，队列为无界队列
* 只能指定初始的队列大小，后面插入元素的时候，**如果空间不够的话会自动扩容**
* 简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异
* 插入操作 put 方法不会 block，因为它是无界队列

### ConcurrentSkipListMap

* 内部采用跳表实现
* 在高并发的情况下，只需要部分锁即可，可以拥有更好的性能
* 就查询的性能**O(logn)**

#### 跳表概念

![](https://camo.githubusercontent.com/111e9bd4936833f774e1a11a2e7bead849ec0ab2/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d392f33323030353733382e6a7067)

* 维护多个链表，链表是分层的
* 最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集
* 所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。**也就是说在查找过程中，搜索是跳跃式的**
* **利用空间换时间的算法**
* 与哈希算法实现的Map区别
  * 哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的