# Linux操作系统

[TOC]



## 系统调用

### write

- 触发延迟写(delayed write)进制
- Linux在内核提供页缓冲区用来提高硬盘IO性能
- write操作在写入系统缓冲区后直接返回
- 同步硬盘操作依赖于系统调用机制
- 同步文件治安，如果此时系统宕机，缓冲区的数据将丢失

### fsync

- 针对单个文件操作，做强制硬盘同步
- fsync将阻塞直到写入硬盘后返回，保证了数据的持久化

## IO模型

### 基本概念

#### 同步与异步

- 同步：在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回
- 异步：*调用*在发出之后，这个调用就直接返回了，所以没有返回结果
- 与消息的通知机制有关。也就是同步与异步主要是从消息通知机制角度来说的。

#### 阻塞与非阻塞

- 阻塞：指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回
- 非阻塞：指在不能立刻得到结果之前，该调用不会阻塞当前线程
- 与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。

### IO操作

- 概述

  - 对硬盘的读写
  - 对socket的读写以及外设的读写

- 步骤

  - 当用户线程发起一个IO请求操作，内核会去查看要读取的数据是否就绪(磁盘把数据装载到内核的内存空间)
    - 对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；
    - 对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪
  - 当数据就绪之后，内核便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作

- 完整过程：

  此进程需要对磁盘中的数据进行操作，则会向内核发起一个系统调用，然后此进程，将会被切换出去，此进程会被挂起或者进入睡眠状态，也叫不可中断的睡眠，因为数据还没有得到，只有等到系统调用的结果完成后，则进程会被唤醒，继续接下来的操作，从系统调用的开始到系统调用结束经过的步骤：

  1. 进程向内核发起一个系统调用，
  2. 内核接收到系统调用，知道是对文件的请求，于是告诉磁盘，把文件读取出来
  3. 磁盘接收到来着内核的命令后，把文件载入到内核的内存空间里面
  4. 内核的内存空间接收到数据之后，把数据copy到用户进程的内存空间(此过程是I/O发生的地方)
  5. 进程内存空间得到数据后，给内核发送通知
  6. 内核把接收到的通知回复给进程，此过程为唤醒进程，然后进程得到数据，进行下一步操作

### IO概念

#### 阻塞IO

如果数据没有就绪，在查看数据是否就绪的过程中一直等待

#### 非阻塞IO

如果数据没有就绪，在查看数据是否就绪的过程中直接返回一个标志信息

#### 同步IO

- 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞
- 当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程

#### 异步IO

- 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞
- 只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成
- 在异步IO中，不会对用户线程产生任何阻塞

- 同步IO与异步IO区别
  - 关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。
  - 所以说异步IO必须要有操作系统的底层支持

### 5种IO模型

 前四种I/O属于同步操作，最后的一种则属于异步操作

![](https://s1.51cto.com/attachment/201309/212627938.png)

#### 阻塞IO模型

##### 概述

* 最传统的一种IO模型，即在读写数据过程中会发生阻塞现象
* 当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。
* 当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。

##### 示例

``` Java
data = socket.read();

//如果数据没有就绪，就会一直阻塞在read方法。
```

#### 非阻塞IO

##### 概述

- 当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。
  - 如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。
  - 一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。
- 事实上，**在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU**

##### 示例

``` java
while(true){

    data = socket.read();

    if(data!= error){

        处理数据

        break;

    }

}

// 但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。
```

#### 多路复用IO

##### 概述

- 多路复用IO模型是目前使用得比较多的模型。**Java NIO实际上就是多路复用IO**。
- 在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。
- 因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。

##### 多路复用IO为何比非阻塞IO模型的效率高

- 因为**在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的**
- 而**在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多**

#### 信号驱动IO

##### 概述

- 在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。

#### 异步IO

##### 概述

- 在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。
- 另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block
- 然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了
- 也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。
- 也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。
  - 用户线程中不需要再次调用IO函数进行具体的读写。

## select、poll、epoll之间的区别总结

[《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)

### 过程

* 把进程的文件描述符fd集合从用户空间拷贝到内核空间(一个进程打开多个文件就有多少fd)
  * select/poll：进程每次select都会拷贝一次，epoll保证每个fd只拷贝一次
* select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替；epoll为每个fd注册了回调函数，然后不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒进入睡眠的进程。
* 把进程的文件描述符fd集合从内核空间拷贝到用户空间

### 共同点

* 　select，poll，epoll都是IO多路复用的机制。
  * I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
* **elect，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**

### 区别

- **select 有打开文件描述符数量限制**，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；**poll采用链表结构，没有数量限制。** **epoll也没有数量限制**
- select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。
- poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。
- 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。